<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BitMiracle.LibTiff.NET</name>
    </assembly>
    <members>
        <member name="T:BitMiracle.LibTiff.Classic.CleanFaxData">
            <summary>
            Regenerated line info.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.CLEANFAXDATA tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.CLEAN">
            <summary>
            No errors detected.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.REGENERATED">
            <summary>
            Receiver regenerated lines.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.CleanFaxData.UNCLEAN">
            <summary>
            Uncorrected errors exist.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ColorResponseUnit">
            <summary>
            Color curve accuracy.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.COLORRESPONSEUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU10S">
            <summary>
            Tenths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU100S">
            <summary>
            Hundredths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU1000S">
            <summary>
            Thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU10000S">
            <summary>
            Ten-thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ColorResponseUnit.CRU100000S">
            <summary>
            Hundred-thousandths.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Compression">
            <summary>
            Compression scheme.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.COMPRESSION tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.NONE">
            <summary>
            Dump mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTRLE">
            <summary>
            CCITT modified Huffman RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTFAX3">
            <summary>
            CCITT Group 3 fax encoding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITT_T4">
            <summary>
            CCITT T.4 (TIFF 6 name for CCITT Group 3 fax encoding).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTFAX4">
            <summary>
            CCITT Group 4 fax encoding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITT_T6">
            <summary>
            CCITT T.6 (TIFF 6 name for CCITT Group 4 fax encoding).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.LZW">
            <summary>
            Lempel-Ziv &amp; Welch.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.OJPEG">
            <summary>
            Original JPEG / Old-style JPEG (6.0).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JPEG">
            <summary>
            JPEG DCT compression. Introduced post TIFF rev 6.0.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.NEXT">
            <summary>
            NeXT 2-bit RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.CCITTRLEW">
            <summary>
            CCITT RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PACKBITS">
            <summary>
            Macintosh RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.THUNDERSCAN">
            <summary>
            ThunderScan RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8CTPAD">
            <summary>
            IT8 CT w/padding. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8LW">
            <summary>
            IT8 Linework RLE. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8MP">
            <summary>
            IT8 Monochrome picture. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.IT8BL">
            <summary>
            IT8 Binary line art. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PIXARFILM">
            <summary>
            Pixar companded 10bit LZW. Reserved for Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.PIXARLOG">
            <summary>
            Pixar companded 11bit ZIP. Reserved for Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.DEFLATE">
            <summary>
            Deflate compression.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.ADOBE_DEFLATE">
            <summary>
            Deflate compression, as recognized by Adobe.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.DCS">
            <summary>
            Kodak DCS encoding.
            Reserved for Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JBIG">
            <summary>
            ISO JBIG.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.SGILOG">
            <summary>
            SGI Log Luminance RLE.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.SGILOG24">
            <summary>
            SGI Log 24-bit packed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Compression.JP2000">
            <summary>
            Leadtools JPEG2000.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ExtraSample">
            <summary>
            Information about extra samples.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.EXTRASAMPLES tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.UNSPECIFIED">
            <summary>
            Unspecified data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.ASSOCALPHA">
            <summary>
            Associated alpha data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ExtraSample.UNASSALPHA">
            <summary>
            Unassociated alpha data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FaxMode">
            <summary>
            Group 3/4 format control.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.FAXMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.CLASSIC">
            <summary>
            Default, include RTC.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.NORTC">
            <summary>
            No RTC at end of data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.NOEOL">
            <summary>
            No EOL code at end of row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.BYTEALIGN">
            <summary>
            Byte align row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.WORDALIGN">
            <summary>
            Word align row.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FaxMode.CLASSF">
            <summary>
            TIFF Class F.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FileType">
            <summary>
            Subfile data descriptor.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.SUBFILETYPE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.REDUCEDIMAGE">
            <summary>
            Reduced resolution version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.PAGE">
            <summary>
            One page of many.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FileType.MASK">
            <summary>
            Transparency mask.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FillOrder">
            <summary>
            Data order within a byte.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.FILLORDER tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FillOrder.MSB2LSB">
            <summary>
            Most significant -> least.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FillOrder.LSB2MSB">
            <summary>
            Least significant -> most.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.GrayResponseUnit">
            <summary>
            Gray scale curve accuracy.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.GRAYRESPONSEUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU10S">
            <summary>
            Tenths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU100S">
            <summary>
            Hundredths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU1000S">
            <summary>
            Thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU10000S">
            <summary>
            Ten-thousandths of a unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.GrayResponseUnit.GRU100000S">
            <summary>
            Hundred-thousandths.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Group3Opt">
            <summary>
            Options for CCITT Group 3/4 fax encoding.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.GROUP3OPTIONS / TiffTag.T4OPTIONS and
            TiffTag.GROUP4OPTIONS / TiffTag.T6OPTIONS tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.UNKNOWN">
            <summary>
            Unknown (uninitialized).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.ENCODING2D">
            <summary>
            2-dimensional coding.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.UNCOMPRESSED">
            <summary>
            Data not compressed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Group3Opt.FILLBITS">
            <summary>
            Fill to byte boundary.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.InkSet">
            <summary>
            Inks in separated image.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.INKSET tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.InkSet.CMYK">
            <summary>
            Cyan-magenta-yellow-black color.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.InkSet.MULTIINK">
            <summary>
            Multi-ink or hi-fi color.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegColorMode">
            <summary>
            Auto RGB&lt;=&gt;YCbCr convert.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.JPEGCOLORMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegColorMode.RAW">
            <summary>
            No conversion (default).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegColorMode.RGB">
            <summary>
            Do auto conversion.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegProc">
            <summary>
            JPEG processing algorithm.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.JPEGPROC tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegProc.BASELINE">
            <summary>
            Baseline sequential.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegProc.LOSSLESS">
            <summary>
            Huffman coded lossless.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.JpegTablesMode">
            <summary>
            Jpeg Tables Mode.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.JPEGTABLESMODE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.NONE">
            <summary>
            None.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.QUANT">
            <summary>
            Include quantization tables.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.JpegTablesMode.HUFF">
            <summary>
            Include Huffman tables.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.OFileType">
            <summary>
            Kind of data in subfile.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.OSUBFILETYPE tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.IMAGE">
            <summary>
            Full resolution image data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.REDUCEDIMAGE">
            <summary>
            Reduced size image data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.OFileType.PAGE">
            <summary>
            One page of many.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Orientation">
            <summary>
            Image orientation.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.ORIENTATION tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.TOPLEFT">
            <summary>
            Row 0 top, Column 0 lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.TOPRIGHT">
            <summary>
            Row 0 top, Column 0 rhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.BOTRIGHT">
            <summary>
            Row 0 bottom, Column 0 rhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.BOTLEFT">
            <summary>
            Row 0 bottom, Column 0 lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.LEFTTOP">
            <summary>
            Row 0 lhs, Column 0 top.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.RIGHTTOP">
            <summary>
            Row 0 rhs, Column 0 top.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.RIGHTBOT">
            <summary>
            Row 0 rhs, Column 0 bottom.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Orientation.LEFTBOT">
            <summary>
            Row 0 lhs, Column 0 bottom.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Photometric">
            <summary>
            Photometric interpretation.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.PHOTOMETRIC tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MINISWHITE">
            <summary>
            Min value is white.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MINISBLACK">
            <summary>
            Min value is black.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.RGB">
            <summary>
            RGB color model.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.PALETTE">
            <summary>
            Color map indexed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.MASK">
            <summary>
            [obsoleted by TIFF rev. 6.0] Holdout mask.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.SEPARATED">
            <summary>
            Color separations.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.YCBCR">
            <summary>
            CCIR 601.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.CIELAB">
            <summary>
            1976 CIE L*a*b*.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.ICCLAB">
            <summary>
            ICC L*a*b*. Introduced post TIFF rev 6.0 by Adobe TIFF Technote 4.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.ITULAB">
            <summary>
            ITU L*a*b*.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.LOGL">
            <summary>
            CIE Log2(L).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Photometric.LOGLUV">
            <summary>
            CIE Log2(L) (u',v').
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.PlanarConfig">
            <summary>
            Storage organization.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.PLANARCONFIG tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.UNKNOWN">
            <summary>
            Unknown (uninitialized).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.CONTIG">
            <summary>
            Single image plane.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.PlanarConfig.SEPARATE">
            <summary>
            Separate planes of data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Predictor">
            <summary>
            Prediction scheme w/ LZW.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.PREDICTOR tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.NONE">
            <summary>
            No prediction scheme used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.HORIZONTAL">
            <summary>
            Horizontal differencing.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Predictor.FLOATINGPOINT">
            <summary>
            Floating point predictor.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.ResUnit">
            <summary>
            Units of resolutions.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.RESOLUTIONUNIT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.NONE">
            <summary>
            No meaningful units.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.INCH">
            <summary>
            English.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.ResUnit.CENTIMETER">
            <summary>
            Metric.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.SampleFormat">
            <summary>
            Data sample format.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.SAMPLEFORMAT tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.UINT">
            <summary>
            Unsigned integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.INT">
            <summary>
            Signed integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.IEEEFP">
            <summary>
            IEEE floating point data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.VOID">
            <summary>
            Untyped data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.COMPLEXINT">
            <summary>
            Complex signed int
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.SampleFormat.COMPLEXIEEEFP">
            <summary>
            Complex ieee floating
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Threshold">
            <summary>
            Thresholding used on data.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.THRESHHOLDING tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.BILEVEL">
            <summary>
            B&amp;W art scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.HALFTONE">
            <summary>
            Dithered scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Threshold.ERRORDIFFUSE">
            <summary>
            Usually Floyd-Steinberg.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffPrintFlags">
            <summary>
            Flags that can be passed to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory"/>
            method to control printing of data structures that are potentially very large.
            </summary>
            <remarks>More than one flag can be used. Bit-or these flags to enable printing
            multiple items.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.NONE">
            <summary>
            no extra info
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.STRIPS">
            <summary>
            strips/tiles info
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.CURVES">
            <summary>
            color/gray response curves
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.COLORMAP">
            <summary>
            colormap
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGQTABLES">
            <summary>
            JPEG Q matrices
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGACTABLES">
            <summary>
            JPEG AC tables
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffPrintFlags.JPEGDCTABLES">
            <summary>
            JPEG DC tables
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffTag">
            <summary>
            TIFF tag definitions.
            </summary>
            <remarks>
            Joris Van Damme maintains
            <a href="http://www.awaresystems.be/imaging/tiff/tifftags.html" target="_blank">
            TIFF Tag Reference</a>, good source of tag information. It's an overview of known TIFF
            Tags with properties, short description, and other useful information.
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IGNORE">
            <summary>
            Tag placeholder
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SUBFILETYPE">
            <summary>
            Subfile data descriptor.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FileType"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OSUBFILETYPE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Kind of data in subfile. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.OFileType"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH">
            <summary>
            Image width in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH">
            <summary>
            Image height in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE">
            <summary>
            Bits per channel (sample).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COMPRESSION">
            <summary>
            Data compression technique.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Compression"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PHOTOMETRIC">
            <summary>
            Photometric interpretation.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Photometric"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.THRESHHOLDING">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Thresholding used on data. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Threshold"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CELLWIDTH">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Dithering matrix width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CELLLENGTH">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Dithering matrix height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER">
            <summary>
            Data order within a byte.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FillOrder"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DOCUMENTNAME">
            <summary>
            Name of document which holds for image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDESCRIPTION">
            <summary>
            Information about image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAKE">
            <summary>
            Scanner manufacturer name.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MODEL">
            <summary>
            Scanner model name/number.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS">
            <summary>
            Offsets to data strips.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIENTATION">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Image orientation. For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Orientation"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL">
            <summary>
            Samples per pixel.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP">
            <summary>
            Rows per strip of data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS">
            <summary>
            Bytes counts for strips.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MINSAMPLEVALUE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Minimum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAXSAMPLEVALUE">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XRESOLUTION">
            <summary>
            Pixels/resolution in x.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YRESOLUTION">
            <summary>
            Pixels/resolution in y.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG">
            <summary>
            Storage organization.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PAGENAME">
            <summary>
            Page name image is from.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XPOSITION">
            <summary>
            X page offset of image lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YPOSITION">
            <summary>
            Y page offset of image lhs.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FREEOFFSETS">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Byte offset to free block.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FREEBYTECOUNTS">
            <summary>
            [obsoleted by TIFF rev. 5.0]<br/>
            Sizes of free blocks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GRAYRESPONSEUNIT">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br/>
            Gray scale curve accuracy.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.GrayResponseUnit"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GRAYRESPONSECURVE">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br/>
            Gray scale response curve.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GROUP3OPTIONS">
            <summary>
            Options for CCITT Group 3 fax encoding. 32 flag bits.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Group3Opt"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.T4OPTIONS">
            <summary>
            TIFF 6.0 proper name alias for GROUP3OPTIONS.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GROUP4OPTIONS">
            <summary>
            Options for CCITT Group 4 fax encoding. 32 flag bits.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Group3Opt"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.T6OPTIONS">
            <summary>
            TIFF 6.0 proper name alias for GROUP4OPTIONS.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RESOLUTIONUNIT">
            <summary>
            Units of resolutions.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ResUnit"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PAGENUMBER">
            <summary>
            Page numbers of multi-page.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORRESPONSEUNIT">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br/>
            Color curve accuracy.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ColorResponseUnit"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TRANSFERFUNCTION">
            <summary>
            Colorimetry info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SOFTWARE">
            <summary>
            Name &amp; release.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DATETIME">
            <summary>
            Creation date and time.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ARTIST">
            <summary>
            Creator of image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.HOSTCOMPUTER">
            <summary>
            Machine where created.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PREDICTOR">
            <summary>
            Prediction scheme w/ LZW.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.Predictor"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WHITEPOINT">
            <summary>
            Image white point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PRIMARYCHROMATICITIES">
            <summary>
            Primary chromaticities.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMAP">
            <summary>
            RGB map for pallette image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.HALFTONEHINTS">
            <summary>
            Highlight + shadow info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH">
            <summary>
            Tile width in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH">
            <summary>
            Tile height in pixels.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEOFFSETS">
            <summary>
            Offsets to data tiles.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEBYTECOUNTS">
            <summary>
            Byte counts for tiles.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BADFAXLINES">
            <summary>
            Lines with wrong pixel count.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CLEANFAXDATA">
            <summary>
            Regenerated line info.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.CleanFaxData"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CONSECUTIVEBADFAXLINES">
            <summary>
            Max consecutive bad lines.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SUBIFD">
            <summary>
            Subimage descriptors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INKSET">
            <summary>
            Inks in separated image.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.InkSet"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INKNAMES">
            <summary>
            ASCII names of inks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.NUMBEROFINKS">
            <summary>
            Number of inks.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DOTRANGE">
            <summary>
            0% and 100% dot codes.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TARGETPRINTER">
            <summary>
            Separation target.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXTRASAMPLES">
            <summary>
            Information about extra samples.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.ExtraSample"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLEFORMAT">
            <summary>
            Data sample format.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.SampleFormat"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SMINSAMPLEVALUE">
            <summary>
            Variable MinSampleValue.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SMAXSAMPLEVALUE">
            <summary>
            Variable MaxSampleValue.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CLIPPATH">
            <summary>
            ClipPath. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XCLIPPATHUNITS">
            <summary>
            XClipPathUnits. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCLIPPATHUNITS">
            <summary>
            YClipPathUnits. Introduced post TIFF rev 6.0 by Adobe TIFF technote 2.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INDEXED">
            <summary>
            Indexed. Introduced post TIFF rev 6.0 by Adobe TIFF Technote 3.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGTABLES">
            <summary>
            JPEG table stream. Introduced post TIFF rev 6.0.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OPIPROXY">
            <summary>
            OPI Proxy. Introduced post TIFF rev 6.0 by Adobe TIFF technote.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGPROC">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            JPEG processing algorithm.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegProc"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGIFOFFSET">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            Pointer to SOI marker.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGIFBYTECOUNT">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            JFIF stream length
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGRESTARTINTERVAL">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            Restart interval length.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGLOSSLESSPREDICTORS">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            Lossless proc predictor.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGPOINTTRANSFORM">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            Lossless point transform.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGQTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            Q matrice offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGDCTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            DCT table offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGACTABLES">
            <summary>
            [obsoleted by Technical Note #2 which specifies a revised JPEG-in-TIFF scheme]<br/>
            AC coefficient offsets.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRCOEFFICIENTS">
            <summary>
            RGB -> YCbCr transform.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRSUBSAMPLING">
            <summary>
            YCbCr subsampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.YCBCRPOSITIONING">
            <summary>
            Subsample positioning.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.YCbCrPosition"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REFERENCEBLACKWHITE">
            <summary>
            Colorimetry info.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.XMLPACKET">
            <summary>
            XML packet. Introduced post TIFF rev 6.0 by Adobe XMP Specification, January 2004.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.OPIIMAGEID">
            <summary>
            OPI ImageID. Introduced post TIFF rev 6.0 by Adobe TIFF technote.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REFPTS">
            <summary>
            Image reference points. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONTACKPOINT">
            <summary>
            Region-xform tack point. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONWARPCORNERS">
            <summary>
            Warp quadrilateral. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REGIONAFFINE">
            <summary>
            Affine transformation matrix. Private tag registered to Island Graphics.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MATTEING">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br/>
            Use EXTRASAMPLE tag. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DATATYPE">
            <summary>
            [obsoleted by TIFF rev. 6.0]<br/>
            Use SAMPLEFORMAT tag. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH">
            <summary>
            Z depth of image. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.TILEDEPTH">
            <summary>
            Z depth/data tile. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_IMAGEFULLWIDTH">
            <summary>
            Full image size in X. This tag is set when an image has been cropped out of a larger
            image. It reflect width of the original uncropped image. The XPOSITION tag can be used
            to determine the position of the smaller image in the larger one.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_IMAGEFULLLENGTH">
            <summary>
            Full image size in Y. This tag is set when an image has been cropped out of a larger
            image. It reflect height of the original uncropped image. The YPOSITION can be used
            to determine the position of the smaller image in the larger one.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_TEXTUREFORMAT">
            <summary>
            Texture map format. Used to identify special image modes and data used by Pixar's
            texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_WRAPMODES">
            <summary>
            S&amp;T wrap modes. Used to identify special image modes and data used by Pixar's
            texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_FOVCOT">
            <summary>
            Cotan(fov) for env. maps. Used to identify special image modes and data used by
            Pixar's texture formats. Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_MATRIX_WORLDTOSCREEN">
            <summary>
            Used to identify special image modes and data used by Pixar's texture formats.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXAR_MATRIX_WORLDTOCAMERA">
            <summary>
            Used to identify special image modes and data used by Pixar's texture formats.
            Private tag registered to Pixar.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WRITERSERIALNUMBER">
            <summary>
            Device serial number. Private tag registered to Eastman Kodak.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COPYRIGHT">
            <summary>
            Copyright string. This tag is listed in the TIFF rev. 6.0 w/ unknown ownership.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RICHTIFFIPTC">
            <summary>
            IPTC TAG from RichTIFF specifications.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8SITE">
            <summary>
            Site name. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORSEQUENCE">
            <summary>
            Color seq. [RGB, CMYK, etc]. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8HEADER">
            <summary>
            DDES Header. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8RASTERPADDING">
            <summary>
            Raster scanline padding. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BITSPERRUNLENGTH">
            <summary>
            The number of bits in short run. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BITSPEREXTENDEDRUNLENGTH">
            <summary>
            The number of bits in long run. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORTABLE">
            <summary>
            LW colortable. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8IMAGECOLORINDICATOR">
            <summary>
            BP/BL image color switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BKGCOLORINDICATOR">
            <summary>
            BP/BL bg color switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8IMAGECOLORVALUE">
            <summary>
            BP/BL image color value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8BKGCOLORVALUE">
            <summary>
            BP/BL bg color value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8PIXELINTENSITYRANGE">
            <summary>
            MP pixel intensity value. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8TRANSPARENCYINDICATOR">
            <summary>
            HC transparency switch. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8COLORCHARACTERIZATION">
            <summary>
            Color characterization table. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8HCUSAGE">
            <summary>
            HC usage indicator. Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8TRAPINDICATOR">
            <summary>
            Trapping indicator (untrapped = 0, trapped = 1). Reserved for ANSI IT8 TIFF/IT.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.IT8CMYKEQUIVALENT">
            <summary>
            CMYK color equivalents.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FRAMECOUNT">
            <summary>
            Sequence Frame Count. Private tag registered to Texas Instruments.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PHOTOSHOP">
            <summary>
            Private tag registered to Adobe for PhotoShop.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIFIFD">
            <summary>
            Pointer to EXIF private directory. This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ICCPROFILE">
            <summary>
            ICC profile data. ?? Private tag registered to Adobe. ??
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JBIGOPTIONS">
            <summary>
            JBIG options. Private tag registered to Pixel Magic.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GPSIFD">
            <summary>
            Pointer to GPS private directory. This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXRECVPARAMS">
            <summary>
            Encoded Class 2 ses. params. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXSUBADDRESS">
            <summary>
            Received SubAddr string. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXRECVTIME">
            <summary>
            Receive time (secs). Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXDCS">
            <summary>
            Encoded fax ses. params, Table 2/T.30. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.STONITS">
            <summary>
            Sample value to Nits. Private tag registered to SGI.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FEDEX_EDR">
            <summary>
            Private tag registered to FedEx.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.INTEROPERABILITYIFD">
            <summary>
            Pointer to Interoperability private directory.
            This tag is documented in EXIF specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGVERSION">
            <summary>
            DNG version number. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGBACKWARDVERSION">
            <summary>
            DNG compatibility version. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.UNIQUECAMERAMODEL">
            <summary>
            Name for the camera model. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LOCALIZEDCAMERAMODEL">
            <summary>
            Localized camera model name. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CFAPLANECOLOR">
            <summary>
            CFAPattern->LinearRaw space mapping. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CFALAYOUT">
            <summary>
            Spatial layout of the CFA. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LINEARIZATIONTABLE">
            <summary>
            Lookup table description. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELREPEATDIM">
            <summary>
            Repeat pattern size for the BlackLevel tag. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVEL">
            <summary>
            Zero light encoding level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELDELTAH">
            <summary>
            Zero light encoding level differences (columns). Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BLACKLEVELDELTAV">
            <summary>
            Zero light encoding level differences (rows). Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.WHITELEVEL">
            <summary>
            Fully saturated encoding level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTSCALE">
            <summary>
            Default scale factors. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTCROPORIGIN">
            <summary>
            Origin of the final image area. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DEFAULTCROPSIZE">
            <summary>
            Size of the final image area. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMATRIX1">
            <summary>
            XYZ->reference color space transformation matrix 1.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.COLORMATRIX2">
            <summary>
            XYZ->reference color space transformation matrix 2.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERACALIBRATION1">
            <summary>
            Calibration matrix 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERACALIBRATION2">
            <summary>
            Calibration matrix 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REDUCTIONMATRIX1">
            <summary>
            Dimensionality reduction matrix 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.REDUCTIONMATRIX2">
            <summary>
            Dimensionality reduction matrix 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ANALOGBALANCE">
            <summary>
            Gain applied the stored raw values. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTNEUTRAL">
            <summary>
            Selected white balance in linear reference space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTWHITEXY">
            <summary>
            Selected white balance in x-y chromaticity coordinates.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINEEXPOSURE">
            <summary>
            How much to move the zero point. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINENOISE">
            <summary>
            Relative noise level. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BASELINESHARPNESS">
            <summary>
            Relative amount of sharpening. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BAYERGREENSPLIT">
            <summary>
            How closely the values of the green pixels in the blue/green rows 
            track the values of the green pixels in the red/green rows.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LINEARRESPONSELIMIT">
            <summary>
            Non-linear encoding range. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CAMERASERIALNUMBER">
            <summary>
            Camera's serial number. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.LENSINFO">
            <summary>
            Information about the lens.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CHROMABLURRADIUS">
            <summary>
            Chroma blur radius. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ANTIALIASSTRENGTH">
            <summary>
            Relative strength of the camera's anti-alias filter.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SHADOWSCALE">
            <summary>
            Used by Adobe Camera Raw. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DNGPRIVATEDATA">
            <summary>
            Manufacturer's private data. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MAKERNOTESAFETY">
            <summary>
            Whether the EXIF MakerNote tag is safe to preserve along with the rest of the EXIF data.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CALIBRATIONILLUMINANT1">
            <summary>
            Illuminant 1. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CALIBRATIONILLUMINANT2">
            <summary>
            Illuminant 2. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.BESTQUALITYSCALE">
            <summary>
            Best quality multiplier. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.RAWDATAUNIQUEID">
            <summary>
            Unique identifier for the raw image data. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIGINALRAWFILENAME">
            <summary>
            File name of the original raw file. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ORIGINALRAWFILEDATA">
            <summary>
            Contents of the original raw file. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ACTIVEAREA">
            <summary>
            Active (non-masked) pixels of the sensor. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.MASKEDAREAS">
            <summary>
            List of coordinates of fully masked pixels. Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTICCPROFILE">
            <summary>
            Used to map cameras's color space into ICC profile space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ASSHOTPREPROFILEMATRIX">
            <summary>
            Used to map cameras's color space into ICC profile space.
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CURRENTICCPROFILE">
            <summary>
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.CURRENTPREPROFILEMATRIX">
            <summary>
            Introduced by Adobe DNG specification.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSHUESHIFTVALUES">
            <summary>
            Undefined tag used by Eastman Kodak, hue shift correction data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXMODE">
            <summary>
            [pseudo tag. not written to file]<br/>
            Group 3/4 format control.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.FaxMode"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGQUALITY">
            <summary>
            [pseudo tag. not written to file]<br/>
            Compression quality level. Quality level is on the IJG 0-100 scale. Default value is 75.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGCOLORMODE">
            <summary>
            [pseudo tag. not written to file]<br/>
            Auto RGB&lt;=&gt;YCbCr convert.
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegColorMode"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.JPEGTABLESMODE">
            <summary>
            [pseudo tag. not written to file]<br/>
            For the list of possible values, see <see cref="T:BitMiracle.LibTiff.Classic.JpegTablesMode"/>.
            Default is <see cref="F:BitMiracle.LibTiff.Classic.JpegTablesMode.QUANT"/> | <see cref="F:BitMiracle.LibTiff.Classic.JpegTablesMode.HUFF"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.FAXFILLFUNC">
            <summary>
            [pseudo tag. not written to file]<br/>
            G3/G4 fill function.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXARLOGDATAFMT">
            <summary>
            [pseudo tag. not written to file]<br/>
            PixarLogCodec I/O data sz.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSIMAGERTYPE">
            <summary>
            [pseudo tag. not written to file]<br/>
            Imager mode &amp; filter.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSINTERPMODE">
            <summary>
            [pseudo tag. not written to file]<br/>
            Interpolation mode.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSBALANCEARRAY">
            <summary>
            [pseudo tag. not written to file]<br/>
            Color balance values.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCORRECTMATRIX">
            <summary>
            [pseudo tag. not written to file]<br/>
            Color correction values.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSGAMMA">
            <summary>
            [pseudo tag. not written to file]<br/>
            Gamma value.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSTOESHOULDERPTS">
            <summary>
            [pseudo tag. not written to file]<br/>
            Toe &amp; shoulder points.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>). 
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCALIBRATIONFD">
            <summary>
            [pseudo tag. not written to file]<br/>
            Calibration file description.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.ZIPQUALITY">
            <summary>
            [pseudo tag. not written to file]<br/>
            Compression quality level.
            Quality level is on the ZLIB 1-9 scale. Default value is -1.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.PIXARLOGQUALITY">
            <summary>
            [pseudo tag. not written to file]<br/>
            PixarLog uses same scale.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.DCSCLIPRECTANGLE">
            <summary>
            [pseudo tag. not written to file]<br/>
            Area of image to acquire.
            Allocated to Oceana Matrix (<a href="mailto:dev@oceana.com">dev@oceana.com</a>).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SGILOGDATAFMT">
            <summary>
            [pseudo tag. not written to file]<br/>
            SGILog user data format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.SGILOGENCODE">
            <summary>
            [pseudo tag. not written to file]<br/>
            SGILog data encoding control.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSURETIME">
            <summary>
            Exposure time.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FNUMBER">
            <summary>
            F number.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREPROGRAM">
            <summary>
            Exposure program.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SPECTRALSENSITIVITY">
            <summary>
            Spectral sensitivity.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_ISOSPEEDRATINGS">
            <summary>
            ISO speed rating.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_OECF">
            <summary>
            Optoelectric conversion factor.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXIFVERSION">
            <summary>
            Exif version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DATETIMEORIGINAL">
            <summary>
            Date and time of original data generation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DATETIMEDIGITIZED">
            <summary>
            Date and time of digital data generation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COMPONENTSCONFIGURATION">
            <summary>
            Meaning of each component.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COMPRESSEDBITSPERPIXEL">
            <summary>
            Image compression mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SHUTTERSPEEDVALUE">
            <summary>
            Shutter speed.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_APERTUREVALUE">
            <summary>
            Aperture.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_BRIGHTNESSVALUE">
            <summary>
            Brightness.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREBIASVALUE">
            <summary>
            Exposure bias.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_MAXAPERTUREVALUE">
            <summary>
            Maximum lens aperture.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTDISTANCE">
            <summary>
            Subject distance.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_METERINGMODE">
            <summary>
            Metering mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_LIGHTSOURCE">
            <summary>
            Light source.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASH">
            <summary>
            Flash.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALLENGTH">
            <summary>
            Lens focal length.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTAREA">
            <summary>
            Subject area.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_MAKERNOTE">
            <summary>
            Manufacturer notes.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_USERCOMMENT">
            <summary>
            User comments.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIME">
            <summary>
            DateTime subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIMEORIGINAL">
            <summary>
            DateTimeOriginal subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBSECTIMEDIGITIZED">
            <summary>
            DateTimeDigitized subseconds.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASHPIXVERSION">
            <summary>
            Supported Flashpix version.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_COLORSPACE">
            <summary>
            Color space information.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_PIXELXDIMENSION">
            <summary>
            Valid image width.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_PIXELYDIMENSION">
            <summary>
            Valid image height.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_RELATEDSOUNDFILE">
            <summary>
            Related audio file.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FLASHENERGY">
            <summary>
            Flash energy.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SPATIALFREQUENCYRESPONSE">
            <summary>
            Spatial frequency response.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANEXRESOLUTION">
            <summary>
            Focal plane X resolution.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANEYRESOLUTION">
            <summary>
            Focal plane Y resolution.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALPLANERESOLUTIONUNIT">
            <summary>
            Focal plane resolution unit.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTLOCATION">
            <summary>
            Subject location.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREINDEX">
            <summary>
            Exposure index.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SENSINGMETHOD">
            <summary>
            Sensing method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FILESOURCE">
            <summary>
            File source.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SCENETYPE">
            <summary>
            Scene type.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CFAPATTERN">
            <summary>
            CFA pattern.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CUSTOMRENDERED">
            <summary>
            Custom image processing.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_EXPOSUREMODE">
            <summary>
            Exposure mode.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_WHITEBALANCE">
            <summary>
            White balance.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DIGITALZOOMRATIO">
            <summary>
            Digital zoom ratio.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_FOCALLENGTHIN35MMFILM">
            <summary>
            Focal length in 35 mm film.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SCENECAPTURETYPE">
            <summary>
            Scene capture type.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_GAINCONTROL">
            <summary>
            Gain control.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_CONTRAST">
            <summary>
            Contrast.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SATURATION">
            <summary>
            Saturation.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SHARPNESS">
            <summary>
            Sharpness.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_DEVICESETTINGDESCRIPTION">
            <summary>
            Device settings description.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_SUBJECTDISTANCERANGE">
            <summary>
            Subject distance range.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.EXIF_IMAGEUNIQUEID">
            <summary>
            Unique image ID.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELPIXELSCALETAG">
            <summary>
            This tag is defining exact affine transformations between raster and model space. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELTIEPOINTTAG">
            <summary>
            This tag stores raster->model tiepoint pairs. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_MODELTRANSFORMATIONTAG">
            <summary>
            This tag is optionally provided for defining exact affine transformations between raster and model space. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_GEOKEYDIRECTORYTAG">
            <summary>
            This tag may be used to store the GeoKey Directory, which defines and references the "GeoKeys". Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_GEODOUBLEPARAMSTAG">
            <summary>
            This tag is used to store all of the DOUBLE valued GeoKeys, referenced by the GeoKeyDirectoryTag. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTag.GEOTIFF_GEOASCIIPARAMSTAG">
            <summary>
            This tag is used to store all of the ASCII valued GeoKeys, referenced by the GeoKeyDirectoryTag. Used in interchangeable GeoTIFF files.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffType">
            <summary>
            Tag data type.
            </summary>
            <remarks>Note: RATIONALs are the ratio of two 32-bit integer values.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.NOTYPE">
            <summary>
            Placeholder.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.ANY">
            <summary>
            For field descriptor searching.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.BYTE">
            <summary>
            8-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.ASCII">
            <summary>
            8-bit bytes with last byte <c>null</c>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SHORT">
            <summary>
            16-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.LONG">
            <summary>
            32-bit unsigned integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.RATIONAL">
            <summary>
            64-bit unsigned fraction.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SBYTE">
            <summary>
            8-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.UNDEFINED">
            <summary>
            8-bit untyped data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SSHORT">
            <summary>
            16-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SLONG">
            <summary>
            32-bit signed integer.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SRATIONAL">
            <summary>
            64-bit signed fraction.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.FLOAT">
            <summary>
            32-bit IEEE floating point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.DOUBLE">
            <summary>
            64-bit IEEE floating point.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.IFD">
            <summary>
            32-bit unsigned integer (offset)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.LONG8">
            <summary>
            BigTIFF 64-bit unsigned long
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.SLONG8">
            <summary>
            BigTIFF 64-bit signed long
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffType.IFD8">
            <summary>
            BigTIFF 64-bit unsigned integer/long (offset)
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.YCbCrPosition">
            <summary>
            Subsample positioning.<br/>
            Possible values for <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.YCBCRPOSITIONING tag.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.YCbCrPosition.CENTERED">
            <summary>
            As in PostScript Level 2
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.YCbCrPosition.COSITED">
            <summary>
            As in CCIR 601-1
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FieldBit">
            <summary>
            Field bits (flags) for tags.
            </summary>
            <remarks>Field bits used to indicate fields that have been set in a directory, and to
            reference fields when manipulating a directory.</remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Ignore">
            <summary>
            This value is used to signify tags that are to be processed
            but otherwise ignored.<br/>
            This permits antiquated tags to be quietly read and discarded. Note that
            a bit <b>is</b> allocated for ignored tags; this is understood by the
            directory reading logic which uses this fact to avoid special-case handling.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Pseudo">
            <summary>
            This value is used to signify pseudo-tags.<br/>
            Pseudo-tags don't normally need field bits since they are not
            written to an output file (by definition). The library also has
            express logic to always query a codec for a pseudo-tag so allocating
            a field bit for one is a waste. If codec wants to promote the notion
            of a pseudo-tag being <i>set</i> or <i>unset</i> then it can do using
            internal state flags without polluting the field bit space defined
            for real tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Custom">
            <summary>
            This value is used to signify custom tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Codec">
            <summary>
            This value is used as a base (starting) value for codec-private tags.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.FieldBit.Last">
            <summary>
            Last usable value for field bit. All tags values should be less than this value.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.FieldValue">
            <summary>
            Holds a value of a Tiff tag.
            </summary>
            <remarks>
            <para>Simply put, it is a wrapper around System.Object, that helps to deal with
            unboxing and conversion of types a bit easier.
            </para><para>
            Please take a look at:
            http://blogs.msdn.com/ericlippert/archive/2009/03/19/representation-and-identity.aspx
            </para></remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.FieldValue.Value">
            <summary>
            Gets the value.
            </summary>
            <value>The value.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToByte">
            <summary>
            Retrieves value converted to byte.
            </summary>
            <returns>The value converted to byte.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToShort">
            <summary>
            Retrieves value converted to short.
            </summary>
            <returns>The value converted to short.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUShort">
            <summary>
            Retrieves value converted to ushort.
            </summary>
            <returns>The value converted to ushort.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToInt">
            <summary>
            Retrieves value converted to int.
            </summary>
            <returns>The value converted to int.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUInt">
            <summary>
            Retrieves value converted to uint.
            </summary>
            <returns>The value converted to uint.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToLong">
            <summary>
            Retrieves value converted to long.
            </summary>
            <returns>The value converted to long.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToFloat">
            <summary>
            Retrieves value converted to float.
            </summary>
            <returns>The value converted to float.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToDouble">
            <summary>
            Retrieves value converted to double.
            </summary>
            <returns>The value converted to double.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToString">
            <summary>
            Retrieves value converted to string.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.        
            </returns>
            <remarks>If value is a byte array, then it gets converted to string using
            Latin1 encoding encoder.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.GetBytes">
            <summary>
            Retrieves value converted to byte array.
            </summary>
            <returns>Value converted to byte array.</returns>
            <remarks>
            <para>If value is byte array then it retrieved unaltered.</para>
            <para>If value is array of short, ushort, int, uint, float or double values then this
            array is converted to byte array</para><para>
            If value is a string then it gets converted to byte array using Latin1 encoding
            encoder.</para><para>
            If value is of any other type then <c>null</c> is returned.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToByteArray">
            <summary>
            Retrieves value converted to array of bytes.
            </summary>
            <returns>Value converted to array of bytes.</returns>
            <remarks><para>If value is array of bytes then it retrieved unaltered.</para>
            <para>If value is array of short, ushort, int or uint values then each element of
            field value gets converted to byte and added to resulting array.</para>
            <para>If value is string then it gets converted to byte[] using Latin1 encoding
            encoder.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToShortArray">
            <summary>
            Retrieves value converted to array of short values.
            </summary>
            <returns>Value converted to array of short values.</returns>
            <remarks><para>If value is array of short values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each pair of bytes is converted to short and
            added to resulting array. If value contains odd amount of bytes, then null is
            returned.</para><para>
            If value is array of ushort, int or uint values then each element of field value gets
            converted to short and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUShortArray">
            <summary>
            Retrieves value converted to array of ushort values.
            </summary>
            <returns>Value converted to array of ushort values.</returns>
            <remarks><para>If value is array of ushort values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each pair of bytes is converted to ushort and
            added to resulting array. If value contains odd amount of bytes, then null is
            returned.</para><para>
            If value is array of short, int or uint values then each element of field value gets
            converted to ushort and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToIntArray">
            <summary>
            Retrieves value converted to array of int values.
            </summary>
            <returns>Value converted to array of int values.</returns>
            <remarks><para>If value is array of int values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each 4 bytes are converted to int and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
            <para>If value is array of short, ushort or uint values then each element of
            field value gets converted to int and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToUIntArray">
            <summary>
            Retrieves value converted to array of uint values.
            </summary>
            <returns>Value converted to array of uint values.</returns>
            <remarks><para>If value is array of uint values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each 4 bytes are converted to uint and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
            <para>If value is array of short, ushort or int values then each element of
            field value gets converted to uint and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.TolongArray">
            <summary>
            Retrieves value converted to array of long values.
            </summary>
            <returns>Value converted to array of long values.</returns>
            <remarks><para>If value is array of long values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each 8 bytes are converted to uint and added to
            resulting array. If value contains amount of bytes that can't be divided by 8 without
            remainder, then null is returned.</para>
            <para>If value is array of short, ushort or int values then each element of
            field value gets converted to long and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToFloatArray">
            <summary>
            Retrieves value converted to array of float values.
            </summary>
            <returns>Value converted to array of float values.</returns>
            <remarks><para>If value is array of float values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each 4 bytes are converted to float and added to
            resulting array. If value contains amount of bytes that can't be divided by 4 without
            remainder, then null is returned.</para>
            <para>If value is array of double values then each element of field value gets
            converted to float and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.FieldValue.ToDoubleArray">
            <summary>
            Retrieves value converted to array of double values.
            </summary>
            <returns>Value converted to array of double values.</returns>
            <remarks><para>If value is array of double values then it retrieved unaltered.</para>
            <para>If value is array of bytes then each 8 bytes are converted to double and added to
            resulting array. If value contains amount of bytes that can't be divided by 8 without
            remainder, then null is returned.</para>
            <para>If value is array of float values then each element of field value gets
            converted to double and added to resulting array.</para><para>
            If value is of any other type then null is returned.</para></remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupDecode"/> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreEncode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
            	<c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c>
            </returns>
            <remarks>
            	<b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Close">
            <summary>
            Flushes any internal data buffers and terminates current operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
            	<b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Decode1D(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G3 1D-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Decode2D(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G3 2D-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode a buffer of pixels.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax3DecodeRLE(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of RLE-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax4Decode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decode the requested amount of G4-encoded data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CCITTCodec.Fax4Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode the requested amount of data.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor">
            <summary>
            Codecs that want to support the Predictor tag should inherit from 
            this class instead of TiffCodec. 
            
            Such codecs should not override default TiffCodec's methods for 
            decode|encode setup and encoding|decoding of row|tile|strip. 
            Codecs with predictor support should override equivalent methods 
            provided by this class.
            
            If codec wants to provide custom tag get|set|print methods, then
            it should pass pointer to a object derived from TiffTagMethods
            as parameter to TIFFPredictorInit
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_predictor">
            <summary>
            predictor tag value
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_stride">
            <summary>
            sample stride over data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_rowSize">
            <summary>
            tile/strip row size
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.m_predictorType">
            <summary>
            horizontal differencer/accumulator
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.fpAcc(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Floating point predictor accumulation routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.fpDiff(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Floating point predictor differencing routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.PredictorDecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a scanline and apply the predictor routine.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.CodecWithPredictor.PredictorDecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a tile/strip and apply the predictor routine. Note that horizontal differencing
            must be done on a row-by-row basis. The width of a "row" has already been calculated
            at pre-decode time according to the strip/tile dimensions.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode"/> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
            	<c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c>
            </returns>
            <remarks>
            	<b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
            	<b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DeflateCodec.ZIPEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.Seek(System.Int32)">
            <summary>
            Seeks the specified row in the strip being processed.
            </summary>
            <param name="row">The row to seek.</param>
            <returns>
            	<c>true</c> if specified row was successfully found; otherwise, <c>false</c>
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DumpModeEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a hunk of pixels.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.DumpModeCodec.DumpModeDecode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a hunk of pixels.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.JpegCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.JpegCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreDecode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupDecode"/> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreEncode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
            	<c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c>
            </returns>
            <remarks>
            	<b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
            	<b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DefStripSize(System.Int32)">
            <summary>
            Calculates and/or constrains a strip size.
            </summary>
            <param name="size">The proposed strip size (may be zero or negative).</param>
            <returns>A strip size to use.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.DefTileSize(System.Int32@,System.Int32@)">
            <summary>
            Calculate and/or constrains a tile size
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use after the call.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGPreEncode(System.Int16)">
            <summary>
            Set encoding state at the start of a strip or tile.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGPostEncode">
            <summary>
            Finish up at the end of a strip or tile.
            </summary>
            <returns></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGDecode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a chunk of pixels.
            "Standard" case: returned data is not downsampled.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGDecodeRaw(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decode a chunk of pixels. 
            Returned data is downsampled per sampling factors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            "Standard" case: incoming data is not downsampled.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.JpegCodec.JPEGEncodeRaw(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            Incoming data is expected to be downsampled per sampling factors.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegErrorManager">
             <summary>
             LibJpeg.Net interface layer.
            
             We handle fatal errors when they are encountered within the JPEG
             library.  We also direct LibJpeg.Net error and warning
             messages through the appropriate LibTiff.Net handlers.
             </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegStdDestination">
            <summary>
            JPEG library destination data manager.
            These routines direct compressed data from LibJpeg.Net into the
            LibTiff.Net output buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegStdSource">
            <summary>
            JPEG library source data manager.
            These routines supply compressed data to LibJpeg.Net
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegTablesDestination">
            <summary>
            Alternate destination manager for outputting to JPEGTables field.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.JpegTablesSource">
            <summary>
            Alternate source manager for reading from JPEGTables.
            We can share all the code except for the init routine.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.LZWCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.LZWCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode"/> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
            	<c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c>
            </returns>
            <remarks>
            	<b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
            	<b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.LZWCodec.LZWEncode(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a chunk of pixels.
            </summary>
            <remarks>
            Uses an open addressing double hashing (no chaining) on the prefix code/next character
            combination. We do a variant of Knuth's algorithm D (vol. 3, sec. 6.4) along with
            G. Knott's relatively-prime secondary probe. Here, the modular division first probe is
            gives way to a faster exclusive-or manipulation. Also do block compression with an
            adaptive reset, whereby the code table is cleared when the compression ratio
            decreases, but after the table fills. The variable-length output codes are re-sized at
            this point, and a CODE_CLEAR is generated for the decoder. 
            </remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreDecode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupDecode"/> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
            	<c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreEncode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns>
            	<c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c>
            </returns>
            <remarks>
            	<b>PostEncode</b> is called after encoding and can be used to release any external
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
            	<b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns>
            	<c>true</c> if operation succeed; otherwise, <c>false</c>
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/></param>
            <param name="desired">The desired</param>
            <returns><c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible.
            Some data source managers may be able to back up, or may have
            additional knowledge about the data which permits a more
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br/><br/>
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br/><br/>
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br/><br/>
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br/>
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br/>
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br/>
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br/>
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br/>
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br/>
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.OJpegSrcManager.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            	<c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            	<c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.
            </returns>
            <remarks>
            	<b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/></param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.PackBitsCodec.PackBitsEncodeChunk(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encode a rectangular chunk of pixels. We break it up into row-sized pieces to insure
            that encoded runs do not span rows. Otherwise, there can be problems with the decoder
            if data is read, for example, by scanlines when it was encoded by strips.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB">
            <summary>
            CIE Lab 1976->RGB support
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.range">
            <summary>
            Size of conversion table
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yr2r">
            <summary>
            Conversion of Yr to r
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yg2g">
            <summary>
            Conversion of Yg to g
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffCIELabToRGB.Yb2b">
            <summary>
            Conversion of Yb to b
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDirectory">
            <summary>
            Internal format of a TIFF directory entry.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_fieldsset">
            <summary>
            bit vector of fields that are set
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_nstrips">
            <summary>
            size of offset and bytecount arrays
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirectory.td_stripbytecountsorted">
            <summary>
            is the bytecount array sorted ascending?
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry">
            <summary>
            TIFF Image File Directories are comprised of a table of field
            descriptors of the form shown below.  The table is sorted in
            ascending order by tag.  The values associated with each entry are
            disjoint and may appear anywhere in the file (so long as they are
            placed on a word boundary).
            
            If the value is 4 bytes or less, then it is placed in the offset
            field to save space.  If the value is less than 4 bytes, it is
            left-justified in the offset field.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.tdir_count">
            <summary>
            number of items; length in spec
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.tdir_offset">
            <summary>
            byte offset to field data
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.TiffDirEntry.SizeInBytes(System.Boolean)">
            <summary>
            size in bytes of the entry depending on the current format
            </summary>
            <param name="isBigTiff">if set to <c>true</c> then the bigtiff size will be returned.</param>
            <returns></returns>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffDisplay">
            <summary>
            Structure for holding information about a display device.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffDisplay.d_mat">
            <summary>
            XYZ -> luminance matrix
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.MSB2LSB">
            <summary>
            Use MSB2LSB (most significant -> least) fill order
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.LSB2MSB">
            <summary>
            Use LSB2MSB (least significant -> most) fill order
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.FILLORDER">
            <summary>
            natural bit fill order for machine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.DIRTYDIRECT">
            <summary>
            current directory must be written
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.BUFFERSETUP">
            <summary>
            data buffers setup
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.CODERSETUP">
            <summary>
            encoder/decoder setup done
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.BEENWRITING">
            <summary>
            written 1+ scanlines to file
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.SWAB">
            <summary>
            byte swap file information
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOBITREV">
            <summary>
            inhibit bit reversal logic
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.MYBUFFER">
            <summary>
            my raw data buffer; free on close
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.ISTILED">
            <summary>
            file is tile, not strip- based
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.POSTENCODE">
            <summary>
            need call to postencode routine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.INSUBIFD">
            <summary>
            currently writing a subifd
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.UPSAMPLED">
            <summary>
            library is doing data up-sampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.STRIPCHOP">
            <summary>
            enable strip chopping support
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.HEADERONLY">
            <summary>
            read header only, do not process the first directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOREADRAW">
            <summary>
            skip reading of raw uncompressed image data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.ISBIGTIFF">
            <summary>
            File is written in bigTiff-format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffFlags.NOBIGTIFF">
            <summary>
            File must not be in bigTiff-format.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_magic">
            <summary>
            magic number (defines byte order)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_version">
            <summary>
            TIFF version number
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_diroff">
            <summary>
            byte offset to first directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_offsize">
            <summary>
            reperesents the size in bytes of the offsets
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffHeader.tiff_fill">
            <summary>
            constant for possibly bigtiff convert
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Internal.TiffHeader.SizeInBytes(System.Boolean)">
            <summary>
            size in bytes of the header depending on the current format
            </summary>
            <param name="isBigTiff">if set to <c>true</c> then the bigtiff size will be returned.</param>
            <returns></returns>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB">
            <summary>
            Convert color value from the YCbCr space to CIE XYZ.
            The colorspace conversion algorithm comes from the IJG v5a code;
            see below for more information on how it works.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Internal.TiffYCbCrToRGB.clamptab">
            <summary>
            range clamping table
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff">
            <summary>
            Tag Image File Format (TIFF)
            </summary>
            <remarks>
            Based on Rev 6.0 from
            <see href="http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf" target="_blank"/>
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_extender">
            <summary>
            Client Tag extension support (from Niles Ritter).
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupBuiltInCodecs">
            <summary>
            Compression schemes statically built into the library.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.tiffFieldInfo">
            <summary>
            NB:   THIS ARRAY IS ASSUMED TO BE SORTED BY TAG.
                  If a tag can have both LONG and SHORT types then the LONG must
                  be placed before the SHORT for writing to work properly.
                  
            NOTE: The second field (field_readcount) and third field
                  (field_writecount) sometimes use the values
                  TiffFieldInfo.Variable (-1), TiffFieldInfo.Variable2 (-3)
                  and TiffFieldInfo.Spp (-2). These values should be used but
                  would throw off the formatting of the code, so please
                  interpret the -1, -2 and -3  values accordingly.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.checkDirOffset(System.UInt64)">
            <summary>
            Checks the directory offset against the list of already seen directory
            offsets.
            </summary>
            <remarks> This is a trick to prevent IFD looping. The one can
            create TIFF file with looped directory pointers. We will maintain a
            list of already seen directories and check every IFD offset against
            that list.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchDirectory(System.UInt64,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry[]@,System.UInt64@)">
            <summary>
            Reads IFD structure from the specified offset.
            </summary>
            <returns>The number of fields in the directory or 0 if failed.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchData(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Byte[])">
            <summary>
            Fetches a contiguous directory item.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchString(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.String@)">
            <summary>
            Fetches an ASCII item from the file.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchFloat(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetch a single floating point value from the offset field and
            return it as a native float.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchByteArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Byte[])">
            <summary>
            Fetches an array of BYTE or SBYTE values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchShortArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int16[])">
            <summary>
            Fetch an array of SHORT or SSHORT values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchULongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.UInt32[])">
            <summary>
            Fetches an array of ULONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchLongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32[])">
            <summary>
            Fetches an array of LONG or SLONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchLong8Array(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int64[])">
            <summary>
            Fetches an array of LONG or SLONG values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchRationalArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Single[])">
            <summary>
            Fetch an array of RATIONAL or SRATIONAL values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchFloatArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Single[])">
            <summary>
            Fetches an array of FLOAT values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchDoubleArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double[])">
            <summary>
            Fetches an array of DOUBLE values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchAnyArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double[])">
            <summary>
            Fetches an array of ANY values.
            </summary>
            <remarks>The actual values are returned as doubles which should be
            able hold all the types. Note in particular that we assume that the
            double return value vector is large enough to read in any
            fundamental type. We use that vector as a buffer to read in the base
            type vector and then convert it in place to double (from end to
            front of course).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchNormalTag(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetches a tag that is not handled by special case code.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleShorts(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int16@)">
            <summary>
            Fetches samples/pixel short values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleLongs(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32@)">
            <summary>
            Fetches samples/pixel long values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchPerSampleAnys(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Double@)">
            <summary>
            Fetches samples/pixel ANY values for the specified tag and verify
            that all values are the same.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchStripThing(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry,System.Int32,System.Int64[]@)">
            <summary>
            Fetches a set of offsets or lengths.
            </summary>
            <remarks>While this routine says "strips", in fact it's also used
            for tiles.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fetchRefBlackWhite(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry)">
            <summary>
            Fetches and sets the RefBlackWhite tag.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.chopUpSingleUncompressedStrip">
            <summary>
            Replace a single strip (tile) of uncompressed data with multiple
            strips (tiles), each approximately 8Kbytes.
            </summary>
            <remarks>This is useful for dealing with large images or for
            dealing with machines with a limited amount of memory.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeDirectory(System.Boolean)">
            <summary>
            Writes the contents of the current directory to the specified file.
            </summary>
            <param name="done">call PostEncode() first, and FreeDirectory() after writing</param>
            <remarks>This routine doesn't handle overwriting a directory with
            auxiliary storage that's been changed.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeNormalTag(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,BitMiracle.LibTiff.Classic.TiffFieldInfo)">
            <summary>
            Writes tags that are not special cased.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupShortLong(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32)">
            <summary>
            Setups a directory entry with either a SHORT or LONG type
            according to the value.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.setupShort(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int16)">
            <summary>
            Setups a SHORT directory entry
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeShortTable(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32,System.Int16[][])">
            <summary>
            Setup a directory entry for an NxM table of shorts, where M is
            known to be 2**bitspersample, and write the associated indirect data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeByteArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Byte[])">
            <summary>
            Write/copy data associated with an ASCII or opaque tag value.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeShortArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int16[])">
            <summary>
            Setup a directory entry of an array of SHORT or SSHORT and write
            the associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeLongArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32[])">
            <summary>
            Setup a directory entry of an array of LONG or SLONG and write the
            associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeRationalArray(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Single[])">
            <summary>
            Setup a directory entry of an array of RATIONAL or SRATIONAL and
            write the associated indirect values.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeAnyArray(BitMiracle.LibTiff.Classic.TiffType,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Int32,System.Double[])">
            <summary>
            Writes an array of "type" values for a specified tag (i.e. this is
            a tag which is allowed to have different types, e.g. SMaxSampleType).
            Internally the data values are represented as double since a double
            can hold any of the TIFF tag types (yes, this should really be an abstract
            type tany_t for portability).  The data is converted into the specified
            type in a temporary buffer and then handed off to the appropriate array
            writer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.writeData(BitMiracle.LibTiff.Classic.Internal.TiffDirEntry@,System.Byte[],System.Int32)">
            <summary>
            Writes a contiguous directory item.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.linkDirectory">
            <summary>
            Link the current directory into the directory chain for the file.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.STRIPCHOP_DEFAULT">
            <summary>
            Support strip chopping (whether or not to convert single-strip 
            uncompressed images to mutiple strips of ~8Kb to reduce memory usage)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.DEFAULT_EXTRASAMPLE_AS_ALPHA">
            <summary>
            Treat extra sample as alpha (default enabled). The RGBA interface 
            will treat a fourth sample with no EXTRASAMPLE_ value as being 
            ASSOCALPHA. Many packages produce RGBA files but don't mark the 
            alpha properly.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.CHECK_JPEG_YCBCR_SUBSAMPLING">
            <summary>
            Pick up YCbCr subsampling info from the JPEG data stream to support 
            files lacking the tag (default enabled).
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_name">
            <summary>
            name of open file
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_mode">
            <summary>
            open mode (O_*)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_diroff">
            <summary>
            file offset of current directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dir">
            <summary>
            internal rep of current directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_row">
            <summary>
            current scanline
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curstrip">
            <summary>
            current strip for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curtile">
            <summary>
            current tile for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_tilesize">
            <summary>
            # of bytes in a tile
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_scanlinesize">
            <summary>
            # of bytes in a scanline
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawdata">
            <summary>
            raw data buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawdatasize">
            <summary>
            # of bytes in raw data buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawcp">
            <summary>
            current spot in raw buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_rawcc">
            <summary>
            bytes unread from raw buffer
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_clientdata">
            <summary>
            callback parameter
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_postDecodeMethod">
            <summary>
            post decoding method type
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_tagmethods">
            <summary>
            tag get/set/print routines
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nextdiroff">
            <summary>
            file offset of following directory
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirlist">
            <summary>
            list of offsets to already seen directories to prevent IFD looping
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirlistsize">
            <summary>
            number of entires in offset list
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dirnumber">
            <summary>
            number of already seen directories
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_header">
            <summary>
            file's header block
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_typeshift">
            <summary>
            data type shift counts
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_typemask">
            <summary>
            data type masks
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curdir">
            <summary>
            current directory (index)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_curoff">
            <summary>
            current offset for read/write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_dataoff">
            <summary>
            current offset for writing dir
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nsubifd">
            <summary>
            remaining subifds to write
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_subifdoff">
            <summary>
            offset for patching SubIFD link
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_col">
            <summary>
            current column (offset by row too)
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_fieldinfo">
            <summary>
            sorted table of registered tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_nfields">
            <summary>
            # entries in registered tag table
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_foundfield">
            <summary>
            cached pointer to already found tag
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_clientinfo">
            <summary>
            extra client information.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.m_stream">
            <summary>
            stream used for read|write|etc.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteCustomDirectory(System.Int64@)">
            <summary>
            Writes custom directory. See ticket #51.
            </summary>
            <param name="pdiroff">Output directory offset.</param>
            <returns><c>true</c> if succeeded; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.postDecode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            post decoding routine
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.NOSTRIP">
            <summary>
            undefined state
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.Tiff.NOTILE">
            <summary>
            undefined state
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.startStrip(System.Int32)">
            <summary>
            Set state to appear as if a strip has just been read in.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fillStrip(System.Int32)">
            <summary>
            Read the specified strip and setup for decoding.
            The data buffer is expanded, as necessary, to hold the strip's data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.fillTile(System.Int32)">
            <summary>
            Read the specified tile and setup for decoding. 
            The data buffer is expanded, as necessary, to hold the tile's data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.appendToStrip(System.Int32,System.Byte[],System.Int32,System.Int64)">
            <summary>
            Appends the data to the specified strip.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc">
            <summary>
            Delegate for LibTiff.Net extender method
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class.</param>
            <remarks>
            <para>Extender method is usually used for registering custom tags.</para>
            <para>To setup extender method that will be called upon creation of
            each instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> object please use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetTagExtender(BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc)"/>
            method.</para>
            </remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.Tiff.FaxFillFunc">
            <summary>
            Delegate for a method used to image decoded spans.        
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="runs">The array of black and white run lengths (white then black).</param>
            <param name="thisRunOffset">The zero-based offset in <paramref name="runs"/> array at
            which current row's run begins.</param>
            <param name="nextRunOffset">The zero-based offset in <paramref name="runs"/> array at
            which next row's run begins.</param>
            <param name="width">The width in pixels of the row.</param>
            <remarks><para>
            To override the default method used to image decoded spans please set
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FAXFILLFUNC"/> tag with an instance of this delegate.</para>
            <para>
            Fill methods can assume the <paramref name="runs"/> array has room for at least
            <paramref name="width"/> runs and can overwrite data in the <paramref name="runs"/>
            array as needed (e.g. to append zero runs to bring the count up to a nice multiple).
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetVersion">
            <summary>
            Gets the library version string.
            </summary>
            <returns>The library version string.</returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.Tiff.AssemblyVersion">
            <summary>
            Gets the version of the library's assembly.
            </summary>
            <value>The version of the library's assembly.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)">
            <summary>
            Gets the R component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The R component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)">
            <summary>
            Gets the G component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The G component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)">
            <summary>
            Gets the B component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The B component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)">
            <summary>
            Gets the A component from ABGR value returned by 
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage">ReadRGBAImage</see>.
            </summary>
            <param name="abgr">The ABGR value.</param>
            <returns>The A component from ABGR value.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindCodec(BitMiracle.LibTiff.Classic.Compression)">
            <summary>
            Retrieves the codec registered for the specified compression scheme.
            </summary>
            <param name="scheme">The compression scheme.</param>
            <returns>The codec registered for the specified compression scheme or <c>null</c>
            if there is no codec registered for the given scheme.</returns>
            <remarks>
            <para>
            LibTiff.Net supports a variety of compression schemes implemented by software codecs.
            Each codec adheres to a modular interface that provides for the decoding and encoding
            of image data; as well as some other methods for initialization, setup, cleanup, and
            the control of default strip and tile sizes. Codecs are identified by the associated
            value of the <see cref="T:BitMiracle.LibTiff.Classic.TiffTag"/>.COMPRESSION tag.
            </para>
            <para>
            Other compression schemes may be registered. Registered schemes can also override the
            built-in versions provided by the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)">
            <summary>
            Adds specified codec to a list of registered codec.
            </summary>
            <param name="codec">The codec to register.</param>
            <remarks>
            This method can be used to augment or override the set of codecs available to an
            application. If the <paramref name="codec"/> is for a scheme that already has a
            registered codec then it is overridden and any images with data encoded with this
            compression scheme will be decoded using the supplied codec.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.UnRegisterCodec(BitMiracle.LibTiff.Classic.TiffCodec)">
            <summary>
            Removes specified codec from a list of registered codecs.
            </summary>
            <param name="codec">The codec to remove from a list of registered codecs.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsCodecConfigured(BitMiracle.LibTiff.Classic.Compression)">
            <summary>
            Checks whether library has working codec for the specific compression scheme.
            </summary>
            <param name="scheme">The scheme to check.</param>
            <returns>
            <c>true</c> if the codec is configured and working; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetConfiguredCodecs">
            <summary>
            Retrieves an array of configured codecs, both built-in and registered by user.
            </summary>
            <returns>An array of configured codecs.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Realloc(System.Byte[],System.Int32)">
            <summary>
            Allocates new byte array of specified size and copies data from the existing to
            the new array.
            </summary>
            <param name="array">The existing array.</param>
            <param name="size">The number of elements in new array.</param>
            <returns>
            The new byte array of specified size with data from the existing array.
            </returns>
            <overloads>Allocates new array of specified size and copies data from the existing to
            the new array.</overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Realloc(System.Int32[],System.Int32)">
            <summary>
            Allocates new integer array of specified size and copies data from the existing to
            the new array.
            </summary>
            <param name="array">The existing array.</param>
            <param name="size">The number of elements in new array.</param>
            <returns>
            The new integer array of specified size with data from the existing array.
            </returns>
            <remarks>Size of the array is in elements, not bytes.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Compare(System.Int16[],System.Int16[],System.Int32)">
            <summary>
            Compares specified number of elements in two arrays.
            </summary>
            <param name="first">The first array to compare.</param>
            <param name="second">The second array to compare.</param>
            <param name="elementCount">The number of elements to compare.</param>
            <returns>
            The difference between compared elements or 0 if all elements are equal.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)">
            <summary>
            Initializes new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class and opens a TIFF file for
            reading or writing.
            </summary>
            <param name="fileName">The name of the file to open.</param>
            <param name="mode">The open mode. Specifies if the file is to be opened for
            reading ("r"), writing ("w"), or appending ("a") and, optionally, whether to override
            certain default aspects of library operation (see remarks).</param>
            <returns>The new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class if specified file is
            successfully opened; otherwise, <c>null</c>.</returns>
            <remarks>
            <para>
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/> opens a TIFF file whose name is <paramref name="fileName"/>. When
            a file is opened for appending, existing data will not be touched; instead new data
            will be written as additional subfiles. If an existing file is opened for writing,
            all previous data is overwritten.
            </para>
            <para>
            If a file is opened for reading, the first TIFF directory in the file is automatically
            read (see <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)"/> for reading directories other than the first). If
            a file is opened for writing or appending, a default directory is automatically
            created for writing subsequent data. This directory has all the default values
            specified in TIFF Revision 6.0: BitsPerSample = 1, ThreshHolding = Threshold.BILEVEL
            (bilevel art scan), FillOrder = MSB2LSB (most significant bit of each data byte is
            filled first), Orientation = TOPLEFT (the 0th row represents the visual top of the
            image, and the 0th column represents the visual left hand side), SamplesPerPixel = 1,
            RowsPerStrip = infinity, ResolutionUnit = INCH, and Compression = NONE. To alter
            these values, or to define values for additional fields, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])"/> must
            be used.
            </para>
            <para>
            The <paramref name="mode"/> parameter can include the following flags in addition to
            the "r", "w", and "a" flags. Note however that option flags must follow the
            read-write-append specification.
            </para>
            <list type="table"><listheader>
            <term>Flag</term><description>Description</description></listheader>
            <item><term>l</term>
            <description>When creating a new file force information be written with Little-Endian
            byte order (but see below).</description></item>
            <item><term>b</term>
            <description>When creating a new file force information be written with Big-Endian
            byte order (but see below).</description></item>
            <item><term>L</term>
            <description>Force image data that is read or written to be treated with bits filled
            from Least Significant Bit (LSB) to Most Significant Bit (MSB). Note that this is the
            opposite to the way the library has worked from its inception.</description></item>
            <item><term>B</term>
            <description>Force image data that is read or written to be treated with bits filled
            from Most Significant Bit (MSB) to Least Significant Bit (LSB); this is the
            default.</description></item>
            <item><term>H</term>
            <description>Force image data that is read or written to be treated with bits filled
            in the same order as the native CPU.</description></item>
            <item><term>C</term>
            <description>Enable the use of "strip chopping" when reading images that are comprised
            of a single strip or tile of uncompressed data. Strip chopping is a mechanism by which
            the library will automatically convert the single-strip image to multiple strips, each
            of which has about 8 Kilobytes of data. This facility can be useful in reducing the
            amount of memory used to read an image because the library normally reads each strip
            in its entirety. Strip chopping does however alter the apparent contents of the image
            because when an image is divided into multiple strips it looks as though the
            underlying file contains multiple separate strips. The default behaviour is to enable 
            strip chopping.</description></item>
            <item><term>c</term>
            <description>Disable the use of strip chopping when reading images.</description></item>
            <item><term>h</term>
            <description>Read TIFF header only, do not load the first image directory. That could
            be useful in case of the broken first directory. We can open the file and proceed to
            the other directories.</description></item>
            <item><term>4</term>
            <description>Create classic TIFF file</description></item>
            <item><term>8</term>
            <description>Create BigTIFF file</description></item></list>
            <para>
            By default the library will create new files with the native byte-order of the CPU on
            which the application is run. This ensures optimal performance and is portable to any
            application that conforms to the TIFF specification. To force the library to use a
            specific byte-order when creating a new file the "b" and "l" option flags may be
            included in the <paramref name="mode"/> parameter; for example, "wb" or "wl".</para>
            <para>The use of the "l" and "b" flags is strongly discouraged. These flags are
            provided solely because numerous vendors do not correctly support TIFF; they only
            support one of the two byte orders. It is strongly recommended that you not use this
            feature except to deal with busted apps that write invalid TIFF.</para>
            <para>The "L", "B", and "H" flags are intended for applications that can optimize
            operations on data by using a particular bit order.  By default the library returns
            data in MSB2LSB bit order. Returning data in the bit order of the native CPU makes the
            most sense but also requires applications to check the value of the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag; something they probably do not do right now.</para>
            <para>The "c" option permits applications that only want to look at the tags, for
            example, to get the unadulterated TIFF tag information.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)">
            <summary>
            Initializes new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class and opens a stream with TIFF data
            for reading or writing.
            </summary>
            <param name="name">The name for the new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class.</param>
            <param name="mode">The open mode. Specifies if the file is to be opened for
            reading ("r"), writing ("w"), or appending ("a") and, optionally, whether to override
            certain default aspects of library operation (see remarks for <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/>
            method for the list of the mode flags).</param>
            <param name="clientData">Some client data. This data is passed as parameter to every
            method of the <see cref="T:BitMiracle.LibTiff.Classic.TiffStream"/> object specified by the
            <paramref name="stream"/> parameter.</param>
            <param name="stream">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffStream"/> class to use for
            reading, writing and seeking of TIFF data.</param>
            <returns>The new instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class if stream is successfully
            opened; otherwise, <c>null</c>.</returns>
            <remarks>
            <para>
            This method can be used to read TIFF data from sources other than file. When custom
            stream class derived from <see cref="T:BitMiracle.LibTiff.Classic.TiffStream"/> is used it is possible to read (or
            write) TIFF data that reside in memory, database, etc.
            </para>
            <para>Please note, that <paramref name="name"/> is an arbitrary string used as
            ID for the created <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>. It's not required to be a file name or anything
            meaningful at all.</para>
            <para>
            Please read remarks for <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/> method for the list of option flags that
            can be specified in <paramref name="mode"/> parameter.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Close">
            <summary>
            Closes a previously opened TIFF file.
            </summary>
            <remarks>
            This method closes a file or stream that was previously opened with <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/>
            or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)"/>.
            Any buffered data are flushed to the file/stream,
            including the contents of the current directory (if modified); and all resources
            are reclaimed.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Dispose">
            <summary>
            Frees and releases all resources allocated by this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagListCount">
            <summary>
            Gets the number of elements in the custom tag list.
            </summary>
            <returns>The number of elements in the custom tag list.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagListEntry(System.Int32)">
            <summary>
            Retrieves the custom tag with specified index.
            </summary>
            <param name="index">The zero-based index of a custom tag to retrieve.</param>
            <returns>The custom tag with specified index.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.MergeFieldInfo(BitMiracle.LibTiff.Classic.TiffFieldInfo[],System.Int32)">
            <summary>
            Merges given field information to existing one.
            </summary>
            <param name="info">The array of <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo"/> objects.</param>
            <param name="count">The number of items to use from the <paramref name="info"/> array.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindFieldInfo(BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Retrieves field information for the specified tag.
            </summary>
            <param name="tag">The tag to retrieve field information for.</param>
            <param name="type">The tiff data type to use us additional filter.</param>
            <returns>The field information for specified tag with specified type or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FindFieldInfoByName(System.String,BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Retrieves field information for the tag with specified name.
            </summary>
            <param name="name">The name of the tag to retrieve field information for.</param>
            <param name="type">The tiff data type to use us additional filter.</param>
            <returns>The field information for specified tag with specified type or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FieldWithTag(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Retrieves field information for the specified tag.
            </summary>
            <param name="tag">The tag to retrieve field information for.</param>
            <returns>The field information for specified tag or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FieldWithName(System.String)">
            <summary>
            Retrieves field information for the tag with specified name.
            </summary>
            <param name="name">The name of the tag to retrieve field information for.</param>
            <returns>The field information for specified tag or <c>null</c> if
            the field information wasn't found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetTagMethods">
            <summary>
            Gets the currently used tag methods.
            </summary>
            <returns>The currently used tag methods.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetTagMethods(BitMiracle.LibTiff.Classic.TiffTagMethods)">
            <summary>
            Sets the new tag methods to use.
            </summary>
            <param name="methods">Tag methods.</param>
            <returns>The previously used tag methods.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetClientInfo(System.String)">
            <summary>
            Gets the extra information with specified name associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
            <param name="name">Name of the extra information to retrieve.</param>
            <returns>The extra information with specified name associated with
            this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> or <c>null</c> if extra information with specified
            name was not found.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetClientInfo(System.Object,System.String)">
            <summary>
            Associates extra information with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
            <param name="data">The information to associate with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.</param>
            <param name="name">The name (label) of the information.</param>
            <remarks>If there is already an extra information with the name specified by
            <paramref name="name"/> it will be replaced by the information specified by
            <paramref name="data"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Flush">
            <summary>
            Flushes pending writes to an open TIFF file.
            </summary>
            <returns><c>true</c> if succeeded; otherwise, <c>false</c></returns>
            <remarks><see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush"/> causes any pending writes for the specified file
            (including writes for the current directory) to be done. In normal operation this call
            is never needed  the library automatically does any flushing required.
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.FlushData"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FlushData">
            <summary>
            Flushes any pending image data for the specified file to be written out.
            </summary>
            <returns><c>true</c> if succeeded; otherwise, <c>false</c></returns>
            <remarks><see cref="M:BitMiracle.LibTiff.Classic.Tiff.FlushData"/> flushes any pending image data for the specified file
            to be written out; directory-related data are not flushed. In normal operation this
            call is never needed  the library automatically does any flushing required.
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file.
            </summary>
            <param name="tag">The tag.</param>
            <returns>The value(s) of a tag in an open TIFF file as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue"/> objects or <c>null</c> if there is no such tag set.</returns>
            <remarks>
            <para>
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)"/> returns the value(s) of a tag or pseudo-tag associated with the
            current directory of the opened TIFF file. The tag is identified by
            <paramref name="tag"/>. The type and number of values returned is dependent on the
            tag being requested. You may want to consult
            <a href = "../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
            <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file or default value(s) of a tag if a tag
            is not defined in the current directory and it has a default value(s).
            </summary>
            <param name="tag">The tag.</param>
            <returns>
            The value(s) of a tag in an open TIFF file as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue"/> objects or <c>null</c> if there is no such tag set and
            tag has no default value.
            </returns>
            <remarks>
            <para>
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetFieldDefaulted(BitMiracle.LibTiff.Classic.TiffTag)"/> returns the value(s) of a tag or pseudo-tag associated
            with the current directory of the opened TIFF file or default value(s) of a tag if a
            tag is not defined in the current directory and it has a default value(s). The tag is
            identified by <paramref name="tag"/>. The type and number of values returned is
            dependent on the tag being requested. You may want to consult
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para>
            <para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para>
            </remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory">
            <summary>
            Reads the contents of the next TIFF directory in an open TIFF file/stream and makes
            it the current directory.
            </summary>
            <returns><c>true</c> if directory was successfully read; otherwise, <c>false</c> if an
            error was encountered, or if there are no more directories to be read.</returns>
            <remarks><para>Directories are read sequentially.</para>
            <para>Applications only need to call <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory"/> to read multiple
            subfiles in a single TIFF file/stream - the first directory in a file/stream is
            automatically read when <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)"/> is called.
            </para><para>
            The images that have a single uncompressed strip or tile of data are automatically
            treated as if they were made up of multiple strips or tiles of approximately 8
            kilobytes each. This operation is done only in-memory; it does not alter the contents
            of the file/stream. However, the construction of the "chopped strips" is visible to
            the application through the number of strips returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfStrips"/>
            or the number of tiles returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfTiles"/>.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadCustomDirectory(System.Int64,BitMiracle.LibTiff.Classic.TiffFieldInfo[],System.Int32)">
            <summary>
            Reads a custom directory from the arbitrary offset within file/stream.
            </summary>
            <param name="offset">The directory offset.</param>
            <param name="info">The array of <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo"/> objects to read from
            custom directory. Standard <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo"/> objects are ignored.</param>
            <param name="count">The number of items to use from
            the <paramref name="info"/> array.</param>
            <returns><c>true</c> if a custom directory was read successfully;
            otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEXIFDirectory(System.Int64)">
            <summary>
            Reads an EXIF directory from the given offset within file/stream.
            </summary>
            <param name="offset">The directory offset.</param>
            <returns><c>true</c> if an EXIF directory was read successfully; 
            otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize">
            <summary>
            Calculates the size in bytes of a row of data as it would be returned in a call to
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadScanline"/>, or as it would be
            expected in a call to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/>.
            </summary>
            <returns>The size in bytes of a row of data.</returns>
            <remarks><b>ScanlineSize</b> calculates size for one sample plane only. Please use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize"/> if you want to get size in bytes of a complete
            decoded and packed raster scanline.</remarks>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RasterScanlineSize">
            <summary>
            Calculates the size in bytes of a complete decoded and packed raster scanline.
            </summary>
            <returns>The size in bytes of a complete decoded and packed raster scanline.</returns>
            <remarks>The value returned by <b>RasterScanlineSize</b> may be different from the
            value returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize"/> if data is stored as separate
            planes (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DefaultStripSize(System.Int32)">
            <summary>
            Computes the number of rows for a reasonable-sized strip according to the current
            settings of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH"/>, <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/>
            and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL"/> tags and any compression-specific requirements.
            </summary>
            <param name="estimate">The esimated value (may be zero).</param>
            <returns>The number of rows for a reasonable-sized strip according to the current
            tag settings and compression-specific requirements.</returns>
            <remarks>If the <paramref name="estimate"/> parameter is non-zero, then it is taken
            as an estimate of the desired strip size and adjusted according to any
            compression-specific requirements. The value returned by <b>DefaultStripSize</b> is
            typically used to define the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP"/> tag. If there is no
            any unusual requirements <b>DefaultStripSize</b> tries to create strips that have
            approximately 8 kilobytes of uncompressed data.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.StripSize">
            <summary>
            Computes the number of bytes in a row-aligned strip.
            </summary>
            <returns>The number of bytes in a row-aligned strip</returns>
            <remarks>
            <para>
            <b>StripSize</b> returns the equivalent size for a strip of data as it would be
            returned in a call to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)"/> or as it would be expected in a
            call to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip"/>.
            </para><para>
            If the value of the field corresponding to <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP"/> is
            larger than the recorded <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>, then the strip size is
            truncated to reflect the actual space required to hold the strip.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.VStripSize(System.Int32)">
            <summary>
            Computes the number of bytes in a row-aligned strip with specified number of rows.
            </summary>
            <param name="rowCount">The number of rows in a strip.</param>
            <returns>
            The number of bytes in a row-aligned strip with specified number of rows.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RawStripSize(System.Int32)">
            <summary>
            Computes the number of bytes in a raw (i.e. not decoded) strip.
            </summary>
            <param name="strip">The zero-based index of a strip.</param>
            <returns>The number of bytes in a raw strip.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)">
            <summary>
            Computes which strip contains the specified coordinates (row, plane).
            </summary>
            <param name="row">The row.</param>
            <param name="plane">The sample plane.</param>
            <returns>The number of the strip that contains the specified coordinates.</returns>
            <remarks>
            A valid strip number is always returned; out-of-range coordinate values are clamped to
            the bounds of the image. The <paramref name="row"/> parameter is always used in
            calculating a strip. The <paramref name="plane"/> parameter is used only if data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfStrips">
            <summary>
            Retrives the number of strips in the image.
            </summary>
            <returns>The number of strips in the image.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DefaultTileSize(System.Int32@,System.Int32@)">
            <summary>
            Computes the pixel width and height of a reasonable-sized tile suitable for setting
            up the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH"/> tags.
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use
            after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use
            after the call.</param>
            <remarks>If the <paramref name="width"/> and <paramref name="height"/> values passed
            in are non-zero, then they are adjusted to reflect any compression-specific
            requirements. The returned width and height are constrained to be a multiple of
            16 pixels to conform with the TIFF specification.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.TileSize">
            <summary>
            Compute the number of bytes in a row-aligned tile.
            </summary>
            <returns>The number of bytes in a row-aligned tile.</returns>
            <remarks><b>TileSize</b> returns the equivalent size for a tile of data as it would be
            returned in a call to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)"/> or as it would be expected in a
            call to <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteTile"/>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.VTileSize(System.Int32)">
            <summary>
            Computes the number of bytes in a row-aligned tile with specified number of rows.
            </summary>
            <param name="rowCount">The number of rows in a tile.</param>
            <returns>
            The number of bytes in a row-aligned tile with specified number of rows.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RawTileSize(System.Int32)">
            <summary>
            Computes the number of bytes in a raw (i.e. not decoded) tile.
            </summary>
            <param name="tile">The zero-based index of a tile.</param>
            <returns>The number of bytes in a raw tile.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.TileRowSize">
            <summary>
            Compute the number of bytes in each row of a tile.
            </summary>
            <returns>The number of bytes in each row of a tile.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Computes which tile contains the specified coordinates (x, y, z, plane).
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="z">The z-coordinate.</param>
            <param name="plane">The sample plane.</param>
            <returns>The number of the tile that contains the specified coordinates.</returns>
            <remarks>
            A valid tile number is always returned; out-of-range coordinate values are
            clamped to the bounds of the image. The <paramref name="x"/> and <paramref name="y"/>
            parameters are always used in calculating a tile. The <paramref name="z"/> parameter
            is used if the image is deeper than 1 slice (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH"/> &gt; 1).
            The <paramref name="plane"/> parameter is used only if data are organized in separate
            planes (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CheckTile(System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Checks whether the specified (x, y, z, plane) coordinates are within the bounds of
            the image.
            </summary>
            <param name="x">The x-coordinate.</param>
            <param name="y">The y-coordinate.</param>
            <param name="z">The z-coordinate.</param>
            <param name="plane">The sample plane.</param>
            <returns><c>true</c> if the specified coordinates are within the bounds of the image;
            otherwise, <c>false</c>.</returns>
            <remarks>The <paramref name="x"/> parameter is checked against the value of the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH"/> tag. The <paramref name="y"/> parameter is checked
            against the value of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag. The <paramref name="z"/>
            parameter is checked against the value of the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH"/> tag
            (if defined). The <paramref name="plane"/> parameter is checked against the value of
            the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.SAMPLESPERPIXEL"/> tag if the data are organized in separate
            planes.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfTiles">
            <summary>
            Retrives the number of tiles in the image.
            </summary>
            <returns>The number of tiles in the image.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Clientdata">
            <summary>
            Returns the custom client data associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
            <returns>The custom client data associated with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetClientdata(System.Object)">
            <summary>
            Asscociates a custom data with this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
            <param name="data">The data to associate.</param>
            <returns>The previously associated data.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetMode">
            <summary>
            Gets the mode with which the underlying file or stream was opened.
            </summary>
            <returns>The mode with which the underlying file or stream was opened.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetMode(System.Int32)">
            <summary>
            Sets the new mode for the underlying file or stream.
            </summary>
            <param name="mode">The new mode for the underlying file or stream.</param>
            <returns>The previous mode with which the underlying file or stream was opened.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled">
            <summary>
            Gets the value indicating whether the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> has a
            tiled organization.
            </summary>
            <returns>
            <c>true</c> if the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> has a tiled organization or
            <c>false</c> if the image data of this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> is organized in strips.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsByteSwapped">
            <summary>
            Gets the value indicating whether the image data was in a different byte-order than
            the host computer.
            </summary>
            <returns><c>true</c> if the image data was in a different byte-order than the host
            computer or <c>false</c> if the TIFF file/stream and local host byte-orders are the
            same.</returns>
            <remarks><para>
            Note that <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)"/>,
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)"/> and
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadScanline"/> methods already
            normally perform byte swapping to local host order if needed.
            </para><para>
            Also note that <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)"/> and <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)"/> do not
            perform byte swapping to local host order.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsUpSampled">
            <summary>
            Gets the value indicating whether the image data returned through the read interface
            methods is being up-sampled.
            </summary>
            <returns>
            <c>true</c> if the data is returned up-sampled; otherwise, <c>false</c>.
            </returns>
            <remarks>The value returned by this method can be useful to applications that want to
            calculate I/O buffer sizes to reflect this usage (though the usual strip and tile size
            routines already do this).</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsMSB2LSB">
            <summary>
            Gets the value indicating whether the image data is being returned in MSB-to-LSB
            bit order.
            </summary>
            <returns>
            <c>true</c> if the data is being returned in MSB-to-LSB bit order (i.e with bit 0 as
            the most significant bit); otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IsBigEndian">
            <summary>
            Gets the value indicating whether given image data was written in big-endian order.
            </summary>
            <returns>
            <c>true</c> if given image data was written in big-endian order; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetStream">
            <summary>
            Gets the tiff stream.
            </summary>
            <returns>The tiff stream.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentRow">
            <summary>
            Gets the current row that is being read or written.
            </summary>
            <returns>The current row that is being read or written.</returns>
            <remarks>The current row is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentDirectory">
            <summary>
            Gets the zero-based index of the current directory.
            </summary>
            <returns>The zero-based index of the current directory.</returns>
            <remarks>The zero-based index returned by this method is suitable for use with
            the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)"/> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.NumberOfDirectories">
            <summary>
            Gets the number of directories in a file.
            </summary>
            <returns>The number of directories in a file.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentDirOffset">
            <summary>
            Retrieves the file/stream offset of the current directory.
            </summary>
            <returns>The file/stream offset of the current directory.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentStrip">
            <summary>
            Gets the current strip that is being read or written.
            </summary>
            <returns>The current strip that is being read or written.</returns>
            <remarks>The current strip is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CurrentTile">
            <summary>
            Gets the current tile that is being read or written.
            </summary>
            <returns>The current tile that is being read or written.</returns>
            <remarks>The current tile is updated each time a read or write is done.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadBufferSetup(System.Byte[],System.Int32)">
            <summary>
            Sets up the data buffer used to read raw (encoded) data from a file.
            </summary>
            <param name="buffer">The data buffer.</param>
            <param name="size">The buffer size.</param>
            <remarks>
            <para>
            This method is provided for client-control of the I/O buffers used by the library.
            Applications need never use this method; it's provided only for "intelligent clients"
            that wish to optimize memory usage and/or eliminate potential copy operations that can
            occur when working with images that have data stored without compression.
            </para>
            <para>
            If the <paramref name="buffer"/> is <c>null</c>, then a buffer of appropriate size is
            allocated by the library. Otherwise, the caller must guarantee that the buffer is
            large enough to hold any individual strip of raw data.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteBufferSetup(System.Byte[],System.Int32)">
            <summary>
            Sets up the data buffer used to write raw (encoded) data to a file.
            </summary>
            <param name="buffer">The data buffer.</param>
            <param name="size">The buffer size.</param>
            <remarks>
            <para>
            This method is provided for client-control of the I/O buffers used by the library.
            Applications need never use this method; it's provided only for "intelligent clients"
            that wish to optimize memory usage and/or eliminate potential copy operations that can
            occur when working with images that have data stored without compression.
            </para>
            <para>
            If the <paramref name="size"/> is -1 then the buffer size is selected to hold a
            complete tile or strip, or at least 8 kilobytes, whichever is greater. If the
            <paramref name="buffer"/> is <c>null</c>, then a buffer of appropriate size is
            allocated by the library.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetupStrips">
            <summary>
            Setups the strips.
            </summary>
            <returns><c>true</c> if setup successfully; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteCheck(System.Boolean,System.String)">
            <summary>
            Verifies that file/stream is writable and that the directory information is
            setup properly.
            </summary>
            <param name="tiles">If set to <c>true</c> then ability to write tiles will be verified;
            otherwise, ability to write strips will be verified.</param>
            <param name="method">The name of the calling method.</param>
            <returns><c>true</c> if file/stream is writeable and the directory information is
            setup properly; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FreeDirectory">
            <summary>
            Releases storage associated with current directory.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CreateDirectory">
            <summary>
            Creates a new directory within file/stream.
            </summary>
            <remarks>The newly created directory will not exist on the file/stream till
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.CheckpointDirectory"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush"/>
            or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Close"/> is called.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.LastDirectory">
            <summary>
            Returns an indication of whether the current directory is the last directory
            in the file.
            </summary>
            <returns><c>true</c> if current directory is the last directory in the file;
            otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)">
            <summary>
            Sets the directory with specified number as the current directory.
            </summary>
            <param name="number">The zero-based number of the directory to set as the
            current directory.</param>
            <returns><c>true</c> if the specified directory was set as current successfully;
            otherwise, <c>false</c></returns>
            <remarks><b>SetDirectory</b> changes the current directory and reads its contents with
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadDirectory"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetSubDirectory(System.Int64)">
            <summary>
            Sets the directory at specified file/stream offset as the current directory.
            </summary>
            <param name="offset">The offset from the beginnig of the file/stream to the directory
            to set as the current directory.</param>
            <returns><c>true</c> if the directory at specified file offset was set as current
            successfully; otherwise, <c>false</c></returns>
            <remarks><b>SetSubDirectory</b> acts like <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetDirectory(System.Int16)"/>, except the
            directory is specified as a file offset instead of an index; this is required for
            accessing subdirectories linked through a SubIFD tag (e.g. thumbnail images).</remarks>        
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.UnlinkDirectory(System.Int16)">
            <summary>
            Unlinks the specified directory from the directory chain.
            </summary>
            <param name="number">The zero-based number of the directory to unlink.</param>
            <returns><c>true</c> if directory was unlinked successfully; otherwise, <c>false</c>.</returns>
            <remarks><b>UnlinkDirectory</b> does not removes directory bytes from the file/stream.
            It only makes them unused.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])">
            <summary>
            Sets the value(s) of a tag in a TIFF file/stream open for writing.
            </summary>
            <param name="tag">The tag.</param>
            <param name="value">The tag value(s).</param>
            <returns><c>true</c> if tag value(s) were set successfully; otherwise, <c>false</c>.</returns>
            <remarks><para>
            <b>SetField</b> sets the value of a tag or pseudo-tag in the current directory
            associated with the open TIFF file/stream. To set the value of a field the file/stream
            must have been previously opened for writing with <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)"/>;
            pseudo-tags can be set whether the file was opened for
            reading or writing. The tag is identified by <paramref name="tag"/>.
            The type and number of values in <paramref name="value"/> is dependent on the tag
            being set. You may want to consult
            <a href = "../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> to become familiar with exact data types and calling
            conventions required for each tag supported by the library.
            </para><para>
            A pseudo-tag is a parameter that is used to control the operation of the library but
            whose value is not read or written to the underlying file.
            </para><para>
            The field will be written to the file when/if the directory structure is updated.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory">
            <summary>
            Writes the contents of the current directory to the file and setup to create a new
            subfile (page) in the same file.
            </summary>
            <returns><c>true</c> if the current directory was written successfully;
            otherwise, <c>false</c></returns>
            <remarks>Applications only need to call <b>WriteDirectory</b> when writing multiple
            subfiles (pages) to a single TIFF file. <b>WriteDirectory</b> is automatically called
            by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Close"/> and <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Flush"/> to write a modified directory if the
            file is open for writing.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.CheckpointDirectory">
            <summary>
            Writes the current state of the TIFF directory into the file to make what is currently
            in the file/stream readable.
            </summary>
            <returns><c>true</c> if the current directory was rewritten successfully;
            otherwise, <c>false</c></returns>
            <remarks>Unlike <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory"/>, <b>CheckpointDirectory</b> does not free
            up the directory data structures in memory, so they can be updated (as strips/tiles
            are written) and written again. Reading such a partial file you will at worst get a
            TIFF read error for the first strip/tile encountered that is incomplete, but you will
            at least get all the valid data in the file before that. When the file is complete,
            just use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory"/> as usual to finish it off cleanly.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RewriteDirectory">
            <summary>
            Rewrites the contents of the current directory to the file and setup to create a new
            subfile (page) in the same file.
            </summary>        
            <returns><c>true</c> if the current directory was rewritten successfully;
            otherwise, <c>false</c></returns>
            <remarks>The <b>RewriteDirectory</b> operates similarly to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory"/>,
            but can be called with directories previously read or written that already have an
            established location in the file. It will rewrite the directory, but instead of place
            it at it's old location (as <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteDirectory"/> would) it will place them at
            the end of the file, correcting the pointer from the preceeding directory or file
            header to point to it's new location. This is particularly important in cases where
            the size of the directory and pointed to data has grown, so it wont fit in the space
            available at the old location. Note that this will result in the loss of the 
            previously used directory space.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory(System.IO.Stream)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream.
            </summary>
            <overloads>
            Prints formatted description of the contents of the current directory to the
            specified stream possibly using specified print options.
            </overloads>
            <param name="stream">The stream.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.PrintDirectory(System.IO.Stream,BitMiracle.LibTiff.Classic.TiffPrintFlags)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream using specified print (formatting) options.
            </summary>
            <param name="stream">The stream.</param>
            <param name="flags">The print (formatting) options.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <overloads>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </overloads>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <returns>
            <c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c>
            </returns>
            <remarks>
            <para>
            <b>ReadScanline</b> reads the data for the specified <paramref name="row"/> into the
            user supplied data buffer <paramref name="buffer"/>. The data are returned
            decompressed and, in the native byte- and bit-ordering, but are otherwise packed
            (see further below). The <paramref name="buffer"/> must be large enough to hold an
            entire scanline of data. Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize"/>
            to find out the size (in bytes) of a scanline buffer. Applications should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int16)"/> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int32,System.Int16)"/> and specify correct sample plane if
            image data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            </para>
            <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            	<c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c>
            </returns>
            <remarks>
            <para>
            <b>ReadScanline</b> reads the data for the specified <paramref name="row"/> and
            specified sample plane <paramref name="plane"/> into the user supplied data buffer
            <paramref name="buffer"/>. The data are returned decompressed and, in the native
            byte- and bit-ordering, but are otherwise packed (see further below). The
            <paramref name="buffer"/> must be large enough to hold an entire scanline of data.
            Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize"/> to find out the size (in
            bytes) of a scanline buffer. Applications may use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)"/> or specify 0 for <paramref name="plane"/>
            parameter if image data is contiguous (i.e not organized in separate planes, 
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.CONTIG).
            </para>
            <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Reads and decodes a scanline of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin storing read and decoded bytes.</param>
            <param name="row">The zero-based index of scanline (row) to read.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            	<c>true</c> if image data were read and decoded successfully; otherwise, <c>false</c>
            </returns>
            <remarks>
            <para>
            <b>ReadScanline</b> reads the data for the specified <paramref name="row"/> and
            specified sample plane <paramref name="plane"/> into the user supplied data buffer
            <paramref name="buffer"/>. The data are returned decompressed and, in the native
            byte- and bit-ordering, but are otherwise packed (see further below). The
            <paramref name="buffer"/> must be large enough to hold an entire scanline of data.
            Applications should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ScanlineSize"/> to find out the size (in
            bytes) of a scanline buffer. Applications may use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadScanline(System.Byte[],System.Int32)"/> or specify 0 for <paramref name="plane"/>
            parameter if image data is contiguous (i.e not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.CONTIG).
            </para>
            <para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a scanline of data to an open TIFF file/stream.</overloads>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <returns>
            	<c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c>
            </returns>
            <remarks>
            <para>
            <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row"/>. Applications should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int16)"/> or
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int32,System.Int16)"/> and specify correct sample plane
            parameter if image data in a file/stream is organized in separate planes (i.e
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            </para><para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para><para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para><para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled"/> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            	<c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c>
            </returns>
            <remarks>
            <para>
            <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row"/> and specified sample plane <paramref name="plane"/>.
            Applications may use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)"/> or specify 0 for
            <paramref name="plane"/> parameter if image data in a file/stream is contiguous (i.e
            not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.CONTIG).
            </para><para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para><para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see
            <a href="../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para><para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled"/> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a scanline of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin reading bytes.</param>
            <param name="row">The zero-based index of scanline (row) to place encoded data at.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            	<c>true</c> if image data were encoded and written successfully; otherwise, <c>false</c>
            </returns>
            <remarks>
            <para>
            <b>WriteScanline</b> encodes and writes to a file at the specified
            <paramref name="row"/> and specified sample plane <paramref name="plane"/>.
            Applications may use <see cref="M:BitMiracle.LibTiff.Classic.Tiff.WriteScanline(System.Byte[],System.Int32)"/> or specify 0 for
            <paramref name="plane"/> parameter if image data in a file/stream is contiguous (i.e
            not organized in separate planes,
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.CONTIG).
            </para><para>
            The data are assumed to be uncompressed and in the native bit- and byte-order of the
            host machine. The data written to the file is compressed according to the compression
            scheme of the current TIFF directory (see further below). If the current scanline is
            past the end of the current subfile, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the scanline (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.CONTIG, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8. The library attempts to hide bit-ordering differences between the image and
            the native machine by converting data from the native machine order.
            </para><para>
            Once data are written to a file/stream for the current directory, the values of
            certain tags may not be altered; see 
            <a href = "../articles/KB/well-known-tags.html">"Well-known tags and their
            value(s) data types"</a> for more information.
            </para><para>
            It is not possible to write scanlines to a file/stream that uses a tiled organization.
            The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.IsTiled"/> can be used to determine if the file/stream is organized as
            tiles or strips.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Reads the image and decodes it into RGBA format raster.
            </summary>
            <overloads>
            Reads the image and decodes it into RGBA format raster.
            </overloads>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <returns><c>true</c> if the image was successfully read and converted; otherwise,
            <c>false</c> is returned if an error was encountered.</returns>
            <remarks><para>
            <b>ReadRGBAImage</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster"/>. The raster is assumed to
            be an array of <paramref name="width"/> times <paramref name="height"/> 32-bit entries,
            where <paramref name="width"/> must be less than or equal to the width of the image
            (<paramref name="height"/> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data are placed in the lower
            part of the raster. Note that the raster is assumed to be organized such that the
            pixel at location (x, y) is <paramref name="raster"/>[y * width + x]; with the raster
            origin in the lower-left hand corner. Please use
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/> if you
            want to specify another raster origin.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            <b>ReadRGBAImage</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently. Raster
            pixels are returned uncorrected by any colorimetry information present in the directory.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            <b>ReadRGBAImage</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> facilities.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage(System.Int32,System.Int32,System.Int32[],System.Boolean)">
            <summary>
            Reads the image and decodes it into RGBA format raster.
            </summary>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="stopOnError">if set to <c>true</c> then an error will terminate the
            operation; otherwise method will continue processing data until all the possible data
            in the image have been requested.</param>
            <returns>
            <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered and stopOnError is <c>false</c>.
            </returns>
            <remarks><para>
            <b>ReadRGBAImage</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster"/>. The raster is assumed to
            be an array of <paramref name="width"/> times <paramref name="height"/> 32-bit entries,
            where <paramref name="width"/> must be less than or equal to the width of the image
            (<paramref name="height"/> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data are placed in the lower
            part of the raster. Note that the raster is assumed to be organized such that the
            pixel at location (x, y) is <paramref name="raster"/>[y * width + x]; with the raster
            origin in the lower-left hand corner. Please use
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/> if you
            want to specify another raster origin.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            <b>ReadRGBAImage</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently. Raster
            pixels are returned uncorrected by any colorimetry information present in the directory.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            <b>ReadRGBAImage</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> facilities.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented(System.Int32,System.Int32,System.Int32[],BitMiracle.LibTiff.Classic.Orientation)">
            <summary>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </summary>
            <overloads>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </overloads>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="orientation">The raster origin position.</param>
            <returns>
            <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered.
            </returns>
            <remarks><para>
            <b>ReadRGBAImageOriented</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster"/>. The raster is assumed to
            be an array of <paramref name="width"/> times <paramref name="height"/> 32-bit entries,
            where <paramref name="width"/> must be less than or equal to the width of the image
            (<paramref name="height"/> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data placement depends on
            <paramref name="orientation"/>. Note that the raster is assumed to be organized such
            that the pixel at location (x, y) is <paramref name="raster"/>[y * width + x]; with
            the raster origin specified by <paramref name="orientation"/> parameter.
            </para><para>
            When <b>ReadRGBAImageOriented</b> is used with <see cref="T:BitMiracle.LibTiff.Classic.Orientation"/>.BOTLEFT for
            the <paramref name="orientation"/> the produced result is the same as retuned by
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/>.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            <b>ReadRGBAImageOriented</b> converts non-8-bit images by scaling sample values.
            Palette, grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            <b>ReadRGBAImageOriented</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> facilities.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented(System.Int32,System.Int32,System.Int32[],BitMiracle.LibTiff.Classic.Orientation,System.Boolean)">
            <summary>
            Reads the image and decodes it into RGBA format raster using specified raster origin.
            </summary>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="orientation">The raster origin position.</param>
            <param name="stopOnError">if set to <c>true</c> then an error will terminate the
            operation; otherwise method will continue processing data until all the possible data
            in the image have been requested.</param>
            <returns>
            <c>true</c> if the image was successfully read and converted; otherwise, <c>false</c>
            is returned if an error was encountered and stopOnError is <c>false</c>.
            </returns>
            <remarks><para>
            <b>ReadRGBAImageOriented</b> reads a strip- or tile-based image into memory, storing the
            result in the user supplied RGBA <paramref name="raster"/>. The raster is assumed to
            be an array of <paramref name="width"/> times <paramref name="height"/> 32-bit entries,
            where <paramref name="width"/> must be less than or equal to the width of the image
            (<paramref name="height"/> may be any non-zero size). If the raster dimensions are
            smaller than the image, the image data is cropped to the raster bounds. If the raster
            height is greater than that of the image, then the image data placement depends on
            <paramref name="orientation"/>. Note that the raster is assumed to be organized such
            that the pixel at location (x, y) is <paramref name="raster"/>[y * width + x]; with
            the raster origin specified by <paramref name="orientation"/> parameter.
            </para><para>
            When <b>ReadRGBAImageOriented</b> is used with <see cref="T:BitMiracle.LibTiff.Classic.Orientation"/>.BOTLEFT for
            the <paramref name="orientation"/> the produced result is the same as retuned by
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/>.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            <b>ReadRGBAImageOriented</b> converts non-8-bit images by scaling sample values.
            Palette, grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            <b>ReadRGBAImageOriented</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> facilities.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])">
            <summary>
            Reads a whole strip of a strip-based image, decodes it and converts it to RGBA format.
            </summary>
            <param name="row">The row.</param>
            <param name="raster">The RGBA raster.</param>
            <returns><c>true</c> if the strip was successfully read and converted; otherwise,
            <c>false</c></returns>
            <remarks>
            <para>
            <b>ReadRGBAStrip</b> reads a single strip of a strip-based image into memory, storing
            the result in the user supplied RGBA <paramref name="raster"/>. If specified strip is
            the last strip, then it will only contain the portion of the strip that is actually
            within the image space. The raster is assumed to be an array of width times
            rowsperstrip 32-bit entries, where width is the width of the image
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEWIDTH"/>) and rowsperstrip is the maximum lines in a strip
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.ROWSPERSTRIP"/>).
            </para><para>
            The <paramref name="row"/> value should be the row of the first row in the strip
            (strip * rowsperstrip, zero based).
            </para><para>
            Note that the raster is assumed to be organized such that the pixel at location (x, y)
            is <paramref name="raster"/>[y * width + x]; with the raster origin in the lower-left
            hand corner of the strip. That is bottom to top organization. When reading a partial
            last strip in the file the last line of the image will begin at the beginning of
            the buffer.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            See <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> for more details on how various image types are
            converted to RGBA values.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            <b>ReadRGBAStrip</b>'s main advantage over the similar
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/> function is that for
            large images a single buffer capable of holding the whole image doesn't need to be
            allocated, only enough for one strip. The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/> function does a
            similar operation for tiled images.
            </para><para>
            <b>ReadRGBAStrip</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> facilities.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Reads a whole tile of a tile-based image, decodes it and converts it to RGBA format.
            </summary>
            <param name="col">The column.</param>
            <param name="row">The row.</param>
            <param name="raster">The RGBA raster.</param>
            <returns><c>true</c> if the strip was successfully read and converted; otherwise,
            <c>false</c></returns>
            <remarks>
            <para><b>ReadRGBATile</b> reads a single tile of a tile-based image into memory,
            storing the result in the user supplied RGBA <paramref name="raster"/>. The raster is
            assumed to be an array of width times length 32-bit entries, where width is the width
            of the tile (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILEWIDTH"/>) and length is the height of a tile
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.TILELENGTH"/>).
            </para><para>
            The <paramref name="col"/> and <paramref name="row"/> values are the offsets from the
            top left corner of the image to the top left corner of the tile to be read. They must
            be an exact multiple of the tile width and length.
            </para><para>
            Note that the raster is assumed to be organized such that the pixel at location (x, y)
            is <paramref name="raster"/>[y * width + x]; with the raster origin in the lower-left
            hand corner of the tile. That is bottom to top organization. Edge tiles which partly
            fall off the image will be filled out with appropriate zeroed areas.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            See <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> for more details on how various image types are
            converted to RGBA values.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            <b>ReadRGBATile</b>'s main advantage over the similar
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/> function is that for
            large images a single buffer capable of holding the whole image doesn't need to be
            allocated, only enough for one tile. The <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/> function does a
            similar operation for stripped images.
            </para><para>
            <b>ReadRGBATile</b> is just a wrapper around the more general
            <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> facilities.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/>
            <seealso cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)">
            <summary>
            Check the image to see if it can be converted to RGBA format.
            </summary>
            <param name="errorMsg">The error message (if any) gets placed here.</param>
            <returns><c>true</c> if the image can be converted to RGBA format; otherwise,
            <c>false</c> is returned and <paramref name="errorMsg"/> contains the reason why it
            is being rejected.</returns>
            <remarks><para>
            To convert the image to RGBA format please use
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImage"/>,
            <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAImageOriented"/>,
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBAStrip(System.Int32,System.Int32[])"/> or <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ReadRGBATile(System.Int32,System.Int32,System.Int32[])"/>
            </para><para>
            Convertible images should follow this rules: samples must be either 1, 2, 4, 8, or
            16 bits; colorimetric samples/pixel must be either 1, 3, or 4 (i.e. SamplesPerPixel
            minus ExtraSamples).</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.FileName">
            <summary>
            Gets the name of the file or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
            <returns>The name of the file or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.</returns>
            <remarks>If this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> was created using <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/> method then
            value of fileName parameter of <see cref="M:BitMiracle.LibTiff.Classic.Tiff.Open(System.String,System.String)"/> method is returned. If this
            <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> was created using
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)"/>
            then value of name parameter of
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ClientOpen(System.String,System.String,System.Object,BitMiracle.LibTiff.Classic.TiffStream)"/>
            method is returned.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetFileName(System.String)">
            <summary>
            Sets the new ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
            <param name="name">The ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.</param>
            <returns>The previous file name or ID string for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.</returns>
            <remarks>Please note, that <paramref name="name"/> is an arbitrary string used as
            ID for this <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>. It's not required to be a file name or anything
            meaningful at all.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Error(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            <para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
            <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error"/>.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Error(System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            <para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
            <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ErrorExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="clientData">The client data to be passed to error handler.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            <para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
            <para>
            The <paramref name="clientData"/> parameter can be anything you want. It will be passed
            unchanged to the error handler. Default error handler does not use it. Only custom
            error handlers may make use of it.
            </para>
            <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error"/> and passes client data to the error handler.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ErrorExt(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide error handling methods to (normally) write an error message
            to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="clientData">The client data to be passed to error handler.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            <para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para>
            <para>
            The <paramref name="clientData"/> parameter can be anything you want. It will be passed
            unchanged to the error handler. Default error handler does not use it. Only custom
            error handlers may make use of it.
            </para>
            <para>Applications that desire to capture control in the event of an error should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Warning(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            <para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter,
            if not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
            <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error"/>.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Warning(System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks><para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter,
            if not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
            <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WarningExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error"/> and passes client data to the warning handler.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="clientData">The client data to be passed to warning handler.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            <para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para>
            <para>
            The <paramref name="clientData"/> parameter can be anything you want. It will be passed
            unchanged to the warning handler. Default warning handler does not use it. Only custom
            warning handlers may make use of it.
            </para>
            <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
            <overloads>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error"/> and passes client data to the warning handler.
            </overloads>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WarningExt(System.Object,System.String,System.String,System.Object[])">
            <summary>
            Invokes the library-wide warning handling methods to (normally) write a warning message
            to the <see cref="P:System.Console.Error"/> and passes client data to the warning handler.
            </summary>
            <param name="clientData">The client data to be passed to warning handler.</param>
            <param name="method">The method in which a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks><para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para><para>
            The <paramref name="clientData"/> parameter can be anything you want. It will be passed
            unchanged to the warning handler. Default warning handler does not use it. Only custom
            warning handlers may make use of it.
            </para>
            <para>Applications that desire to capture control in the event of a warning should use
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> to override the default error and warning handler.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)">
            <summary>
            Sets an instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffErrorHandler"/> class as custom library-wide
            error and warning handler.
            </summary>
            <param name="errorHandler">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffErrorHandler"/> class
            to set as custom library-wide error and warning handler.</param>
            <returns>
            Previous error handler or <c>null</c> if there was no error handler set.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetTagExtender(BitMiracle.LibTiff.Classic.Tiff.TiffExtendProc)">
            <summary>
            Sets the tag extender method.
            </summary>
            <param name="extender">The tag extender method.</param>
            <returns>Previous tag extender method.</returns>
            <remarks>
            Extender method is called upon creation of each instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> object.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Reads and decodes a tile of data from an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer to place read and decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin storing read and decoded bytes.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be read and decoded.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>The number of bytes in the decoded tile or <c>-1</c> if an error occurred.</returns>
            <remarks>
            <para>
            The tile to read and decode is selected by the (x, y, z, plane) coordinates (i.e.
            <b>ReadTile</b> returns the data for the tile containing the specified coordinates.
            The data placed in <paramref name="buffer"/> are returned decompressed and, typically,
            in the native byte- and bit-ordering, but are otherwise packed (see further below).
            The buffer must be large enough to hold an entire tile of data. Applications should
            call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize"/> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x"/> and <paramref name="y"/> parameters are always used by
            <b>ReadTile</b>. The <paramref name="z"/> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH"/> &gt; 1). In other cases the
            value of <paramref name="z"/> is ignored. The <paramref name="plane"/> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE). In other
            cases the value of <paramref name="plane"/> is ignored.
            </para><para>
            The library attempts to hide bit- and byte-ordering differences between the image and
            the native machine by converting data to the native machine order. Bit reversal is
            done if the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a tile of data from an open TIFF file/stream, decompresses it and places
            specified amount of decompressed bytes into the user supplied buffer.
            </summary>
            <param name="tile">The zero-based index of the tile to read.</param>
            <param name="buffer">The buffer to place decompressed tile bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            decompressed tile bytes.</param>
            <param name="count">The maximum number of decompressed tile bytes to be stored
            to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
            <para>
            The value of <paramref name="tile"/> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)"/> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.</para>
            <para>To read a full tile of data the data buffer should typically be at least as
            large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize"/>. If the -1 passed in
            <paramref name="count"/> parameter, the whole tile will be read. You should be sure
            you have enough space allocated for the buffer.</para>
            <para>The library attempts to hide bit- and byte-ordering differences between the
            image and the native machine by converting data to the native machine order. Bit
            reversal is done if the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the undecoded contents of a tile of data from an open TIFF file/stream and places
            specified amount of read bytes into the user supplied buffer.
            </summary>
            <param name="tile">The zero-based index of the tile to read.</param>
            <param name="buffer">The buffer to place read tile bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            read tile bytes.</param>
            <param name="count">The maximum number of read tile bytes to be stored to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
            <para>
            The value of <paramref name="tile"/> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)"/> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.</para>
            <para>To read a full tile of data the data buffer should typically be at least as
            large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RawTileSize(System.Int32)"/>. If the -1 passed in
            <paramref name="count"/> parameter, the whole tile will be read. You should be sure
            you have enough space allocated for the buffer.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a tile of data to an open TIFF file/stream.</overloads>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
            <para>
            The tile to place encoded data is selected by the (x, y, z, plane) coordinates (i.e.
            <b>WriteTile</b> writes data to the tile containing the specified coordinates.
            <b>WriteTile</b> (potentially) encodes the data <paramref name="buffer"/> and writes
            it to open file/stream. The buffer must contain an entire tile of data. Applications
            should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize"/> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x"/> and <paramref name="y"/> parameters are always used by
            <b>WriteTile</b>. The <paramref name="z"/> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH"/> &gt; 1). In other cases the
            value of <paramref name="z"/> is ignored. The <paramref name="plane"/> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE). In other
            cases the value of <paramref name="plane"/> is ignored.
            </para><para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag must be setup before
            writing; <b>WriteTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/> does).
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteTile(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="x">The x-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="y">The y-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="z">The z-coordinate of the pixel within a tile to be encoded and written.</param>
            <param name="plane">The zero-based index of the sample plane.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
            <para>
            The tile to place encoded data is selected by the (x, y, z, plane) coordinates (i.e.
            <b>WriteTile</b> writes data to the tile containing the specified coordinates.
            <b>WriteTile</b> (potentially) encodes the data <paramref name="buffer"/> and writes
            it to open file/stream. The buffer must contain an entire tile of data. Applications
            should call the <see cref="M:BitMiracle.LibTiff.Classic.Tiff.TileSize"/> to find out the size (in bytes) of a tile buffer.
            The <paramref name="x"/> and <paramref name="y"/> parameters are always used by
            <b>WriteTile</b>. The <paramref name="z"/> parameter is used if the image is deeper
            than 1 slice (a value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGEDEPTH"/> &gt; 1). In other cases the
            value of <paramref name="z"/> is ignored. The <paramref name="plane"/> parameter is
            used only if data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE). In other
            cases the value of <paramref name="plane"/> is ignored.
            </para><para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag must be setup before
            writing; <b>WriteTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/> does).
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a strip of data from an open TIFF file/stream, decompresses it and places
            specified amount of decompressed bytes into the user supplied buffer.
            </summary>
            <param name="strip">The zero-based index of the strip to read.</param>
            <param name="buffer">The buffer to place decompressed strip bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            decompressed strip bytes.</param>
            <param name="count">The maximum number of decompressed strip bytes to be stored
            to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
            <para>
            The value of <paramref name="strip"/> is a "raw strip number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)"/> automatically does this when converting an (row, plane) to a
            strip index.</para>
            <para>To read a full strip of data the data buffer should typically be at least
            as large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.StripSize"/>. If the -1 passed in
            <paramref name="count"/> parameter, the whole strip will be read. You should be sure
            you have enough space allocated for the buffer.</para>
            <para>The library attempts to hide bit- and byte-ordering differences between the
            image and the native machine by converting data to the native machine order. Bit
            reversal is done if the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.FILLORDER"/> tag is opposite to the native
            machine bit order. 16- and 32-bit samples are automatically byte-swapped if the file
            was written with a byte order opposite to the native machine byte order.</para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReadRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the undecoded contents of a strip of data from an open TIFF file/stream and
            places specified amount of read bytes into the user supplied buffer.
            </summary>
            <param name="strip">The zero-based index of the strip to read.</param>
            <param name="buffer">The buffer to place read bytes to.</param>
            <param name="offset">The zero-based byte offset in buffer at which to begin storing
            read bytes.</param>
            <param name="count">The maximum number of read bytes to be stored to buffer.</param>
            <returns>The actual number of bytes of data that were placed in buffer or -1 if an
            error was encountered.</returns>
            <remarks>
            <para>
            The value of <paramref name="strip"/> is a "raw strip number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)"/> automatically does this when converting an (row, plane) to a
            strip index.</para>
            <para>To read a full strip of data the data buffer should typically be at least
            as large as the number returned by <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RawStripSize(System.Int32)"/>. If the -1 passed in
            <paramref name="count"/> parameter, the whole strip will be read. You should be sure
            you have enough space allocated for the buffer.</para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a strip of data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <overloads>Encodes and writes a strip of data to an open TIFF file/stream.</overloads>
            <remarks>
            <para>
            <b>WriteEncodedStrip</b> encodes <paramref name="count"/> bytes of raw data from
            <paramref name="buffer"/> and append the result to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip"/> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)"/> automatically does this when converting an (row, plane) to
            a strip index.
            </para><para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes and writes a strip of data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
            <para>
            <b>WriteEncodedStrip</b> encodes <paramref name="count"/> bytes of raw data from
            <paramref name="buffer"/> and append the result to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip"/> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)"/> automatically does this when converting an (row, plane) to
            a strip index.
            </para><para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawStrip(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a strip of raw data to an open TIFF file/stream.
            </summary>
            <overloads>Writes a strip of raw data to an open TIFF file/stream.</overloads>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>
            The number of written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
            <para>
            <b>WriteRawStrip</b> appends <paramref name="count"/> bytes of raw data from
            <paramref name="buffer"/> to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip"/> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)"/> automatically does this when converting an (row, plane) to
            a strip index.
            </para><para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawStrip(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a strip of raw data to an open TIFF file/stream.
            </summary>
            <param name="strip">The zero-based index of the strip to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin reading bytes to be written.</param>
            <param name="count">The maximum number of strip bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>The number of written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
            <para>
            <b>WriteRawStrip</b> appends <paramref name="count"/> bytes of raw data from
            <paramref name="buffer"/> to the specified strip; replacing any
            previously written data. Note that the value of <paramref name="strip"/> is a "raw
            strip number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeStrip(System.Int32,System.Int16)"/> automatically does this when converting an (row, plane) to
            a strip index.
            </para><para>
            If there is no space for the strip, the value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/>
            tag is automatically increased to include the strip (except for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE, where the
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag cannot be changed once the first data are
            written). If the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> is increased, the values of
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPOFFSETS"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.STRIPBYTECOUNTS"/> tags are
            similarly enlarged to reflect data written past the previous end of image.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <overloads>Encodes and writes a tile of data to an open TIFF file/stream.</overloads>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>
            The number of encoded and written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks><para>
            <b>WriteEncodedTile</b> encodes <paramref name="count"/> bytes of raw data from
            <paramref name="buffer"/> and append the result to the end of the specified tile. Note
            that the value of <paramref name="tile"/> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)"/> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para><para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para><para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag must be setup before
            writing; <b>WriteEncodedTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/> does).
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteEncodedTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes and writes a tile of data to an open TIFF file/stream.
            </summary>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with image data to be encoded and written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin reading bytes to be encoded and written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>The number of encoded and written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
            <para>
            <b>WriteEncodedTile</b> encodes <paramref name="count"/> bytes of raw data from
            <paramref name="buffer"/> and append the result to the end of the specified tile. Note
            that the value of <paramref name="tile"/> is a "raw tile number". That is, the caller
            must take into account whether or not the data are organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)"/> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para><para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para><para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag must be setup before
            writing; <b>WriteEncodedTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/> does).
            </para><para>
            The library writes encoded data using the native machine byte order. Correctly
            implemented TIFF readers are expected to do any necessary byte-swapping to correctly
            process image data with value of <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.BITSPERSAMPLE"/> tag greater
            than 8.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Writes a tile of raw data to an open TIFF file/stream.
            </summary>
            <overloads>Writes a tile of raw data to an open TIFF file/stream.</overloads>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>
            The number of written bytes or <c>-1</c> if an error occurred.
            </returns>
            <remarks>
            <para>
            <b>WriteRawTile</b> appends <paramref name="count"/> bytes of raw data to the end of
            the specified tile. Note that the value of <paramref name="tile"/> is a "raw tile
            number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)"/> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para><para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para><para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag must be setup before
            writing; <b>WriteRawTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/> does).
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.WriteRawTile(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a tile of raw data to an open TIFF file/stream.
            </summary>
            <param name="tile">The zero-based index of the tile to write.</param>
            <param name="buffer">The buffer with raw image data to be written.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin reading bytes to be written.</param>
            <param name="count">The maximum number of tile bytes to be read from
            <paramref name="buffer"/>.</param>
            <returns>The number of written bytes or <c>-1</c> if an error occurred.</returns>
            <remarks>
            <para>
            <b>WriteRawTile</b> appends <paramref name="count"/> bytes of raw data to the end of
            the specified tile. Note that the value of <paramref name="tile"/> is a "raw tile
            number". That is, the caller must take into account whether or not the data are
            organized in separate planes
            (<see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE).
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.ComputeTile(System.Int32,System.Int32,System.Int32,System.Int16)"/> automatically does this when converting an (x, y, z, plane)
            coordinate quadruple to a tile number.
            </para><para>
            There must be space for the data. The function clamps individual writes to a tile to
            the tile size, but does not (and can not) check that multiple writes to the same tile
            were performed.
            </para><para>
            A correct value for the <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.IMAGELENGTH"/> tag must be setup before
            writing; <b>WriteRawTile</b> does not support automatically growing the image on
            each write (as <see cref="Overload:BitMiracle.LibTiff.Classic.Tiff.WriteScanline"/> does).
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SetWriteOffset(System.Int64)">
            <summary>
            Sets the current write offset.
            </summary>
            <param name="offset">The write offset.</param>
            <remarks>This should only be used to set the offset to a known previous location
            (very carefully), or to 0 so that the next write gets appended to the end of the file.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.DataWidth(BitMiracle.LibTiff.Classic.TiffType)">
            <summary>
            Gets the number of bytes occupied by the item of given type.
            </summary>
            <param name="type">The type.</param>
            <returns>The number of bytes occupied by the <paramref name="type"/> or 0 if unknown
            data type is supplied.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabShort(System.Int16@)">
            <summary>
            Swaps the bytes in a single 16-bit item.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabLong(System.Int32@)">
            <summary>
            Swaps the bytes in a single 32-bit item.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabDouble(System.Double@)">
            <summary>
            Swaps the bytes in a single double-precision floating-point number.
            </summary>
            <param name="value">The value to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfShort(System.Int16[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 16-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 16-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfShort(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 16-bit items starting at
            specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array"/> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfTriples(System.Byte[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of triples (24-bit items).
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of triples (24-bit items).
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfTriples(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of triples (24-bit items)
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array"/> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong(System.Int32[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 32-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 32-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong8(System.Int64[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 64-bit items.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of 64-bit items.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 32-bit items
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array"/> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfLong8(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of 64-bit items
            starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array"/> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfDouble(System.Double[],System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers.
            </summary>
            <overloads>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers.
            </overloads>
            <param name="array">The array to swap bytes in.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.SwabArrayOfDouble(System.Double[],System.Int32,System.Int32)">
            <summary>
            Swaps the bytes in specified number of values in the array of double-precision
            floating-point numbers starting at specified offset.
            </summary>
            <param name="array">The array to swap bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="array"/> at
            which to begin swapping bytes.</param>
            <param name="count">The number of items to swap bytes in.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReverseBits(System.Byte[],System.Int32)">
            <summary>
            Replaces specified number of bytes in <paramref name="buffer"/> with the
            equivalent bit-reversed bytes.
            </summary>
            <overloads>
            Replaces specified number of bytes in <paramref name="buffer"/> with the
            equivalent bit-reversed bytes.
            </overloads>
            <param name="buffer">The buffer to replace bytes in.</param>
            <param name="count">The number of bytes to process.</param>
            <remarks>
            This operation is performed with a lookup table, which can be retrieved using the
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)"/> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ReverseBits(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Replaces specified number of bytes in <paramref name="buffer"/> with the
            equivalent bit-reversed bytes starting at specified offset.
            </summary>
            <param name="buffer">The buffer to replace bytes in.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer"/> at
            which to begin processing bytes.</param>
            <param name="count">The number of bytes to process.</param>
            <remarks>
            This operation is performed with a lookup table, which can be retrieved using the
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)"/> method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.GetBitRevTable(System.Boolean)">
            <summary>
            Retrieves a bit reversal table.
            </summary>
            <param name="reversed">if set to <c>true</c> then bit reversal table will be
            retrieved; otherwise, the table that do not reverse bit values will be retrieved.</param>
            <returns>The bit reversal table.</returns>
            <remarks>If <paramref name="reversed"/> is <c>false</c> then the table that do not
            reverse bit values will be retrieved. It is a lookup table that can be used as an
            identity function; i.e. NoBitRevTable[n] == n.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToInts(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 32-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer"/> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 32-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToLong8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 64-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer"/> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 64-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.Long8ToByteArray(System.Int64[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 64-bit values into array of bytes.
            </summary>
            <param name="source">The array of 64-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source"/> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 64-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes"/> at
            which to begin storing converted values.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.IntsToByteArray(System.Int32[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 32-bit values into array of bytes.
            </summary>
            <param name="source">The array of 32-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source"/> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 32-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes"/> at
            which to begin storing converted values.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ByteArrayToShorts(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts a byte buffer into array of 16-bit values.
            </summary>
            <param name="buffer">The byte buffer.</param>
            <param name="offset">The zero-based offset in <paramref name="buffer"/> at
            which to begin converting bytes.</param>
            <param name="count">The number of bytes to convert.</param>
            <returns>The array of 16-bit values.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.Tiff.ShortsToByteArray(System.Int16[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Converts array of 16-bit values into array of bytes.
            </summary>
            <param name="source">The array of 16-bit values.</param>
            <param name="srcOffset">The zero-based offset in <paramref name="source"/> at
            which to begin converting bytes.</param>
            <param name="srcCount">The number of 16-bit values to convert.</param>
            <param name="bytes">The byte array to store converted values at.</param>
            <param name="offset">The zero-based offset in <paramref name="bytes"/> at
            which to begin storing converted values.</param>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffCodec">
            <summary>
            Base class for all codecs within the library.
            </summary>
            <remarks><para>
            A codec is a class that implements decoding, encoding, or decoding and encoding of a
            compression algorithm.
            </para><para>
            The library provides a collection of builtin codecs. More codecs may be registered
            through calls to the library and/or the builtin implementations may be overridden.
            </para></remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_tif">
            <summary>
            An instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/>.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_scheme">
            <summary>
            Compression scheme this codec impelements.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffCodec.m_name">
            <summary>
            Codec name.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.#ctor(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.Compression,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffCodec"/> class.
            </summary>
            <param name="tif">An instance of <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class.</param>
            <param name="scheme">The compression scheme for the codec.</param>
            <param name="name">The name of the codec.</param>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffCodec.CanEncode">
            <summary>
            Gets a value indicating whether this codec can encode data.
            </summary>
            <value>
            <c>true</c> if this codec can encode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffCodec.CanDecode">
            <summary>
            Gets a value indicating whether this codec can decode data.
            </summary>
            <value>
            <c>true</c> if this codec can decode data; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Init">
            <summary>
            Initializes this instance.
            </summary>
            <returns><c>true</c> if initialized successfully</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode">
            <summary>
            Setups the decoder part of the codec.
            </summary>
            <returns>
            <c>true</c> if this codec successfully setup its decoder part and can decode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            <b>SetupDecode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PreDecode(System.Int16)">
            <summary>
            Prepares the decoder part of the codec for a decoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns><c>true</c> if this codec successfully prepared its decoder part and ready
            to decode data; otherwise, <c>false</c>.</returns>
            <remarks>
            <b>PreDecode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupDecode"/> and before decoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one row of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/>.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one strip of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/>.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DecodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Decodes one tile of image data.
            </summary>
            <param name="buffer">The buffer to place decoded image data to.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin storing decoded bytes.</param>
            <param name="count">The number of decoded bytes that should be placed
            to <paramref name="buffer"/>.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was decoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode">
            <summary>
            Setups the encoder part of the codec.
            </summary>
            <returns>
            <c>true</c> if this codec successfully setup its encoder part and can encode data;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            <b>SetupEncode</b> is called once before
            <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)"/>.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PreEncode(System.Int16)">
            <summary>
            Prepares the encoder part of the codec for a encoding.
            </summary>
            <param name="plane">The zero-based sample plane index.</param>
            <returns><c>true</c> if this codec successfully prepared its encoder part and ready
            to encode data; otherwise, <c>false</c>.</returns>
            <remarks>
            <b>PreEncode</b> is called after <see cref="M:BitMiracle.LibTiff.Classic.TiffCodec.SetupEncode"/> and before encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.PostEncode">
            <summary>
            Performs any actions after encoding required by the codec.
            </summary>
            <returns><c>true</c> if all post-encode actions succeeded; otherwise, <c>false</c></returns>
            <remarks>
            <b>PostEncode</b> is called after encoding and can be used to release any external 
            resources needed during encoding.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeRow(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one row of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/>.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeStrip(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one strip of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/>.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.EncodeTile(System.Byte[],System.Int32,System.Int32,System.Int16)">
            <summary>
            Encodes one tile of image data.
            </summary>
            <param name="buffer">The buffer with image data to be encoded.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin read image data.</param>
            <param name="count">The maximum number of encoded bytes that can be placed
            to <paramref name="buffer"/>.</param>
            <param name="plane">The zero-based sample plane index.</param>
            <returns>
            	<c>true</c> if image data was encoded successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Close">
            <summary>
            Flushes any internal data buffers and terminates current operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Seek(System.Int32)">
            <summary>
            Seeks the specified row in the strip being processed.
            </summary>
            <param name="row">The row to seek.</param>
            <returns><c>true</c> if specified row was successfully found; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.Cleanup">
            <summary>
            Cleanups the state of the codec.
            </summary>
            <remarks>
            <b>Cleanup</b> is called when codec is no longer needed (won't be used) and can be
            used for example to restore tag methods that were substituted.</remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DefStripSize(System.Int32)">
            <summary>
            Calculates and/or constrains a strip size.
            </summary>
            <param name="size">The proposed strip size (may be zero or negative).</param>
            <returns>A strip size to use.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffCodec.DefTileSize(System.Int32@,System.Int32@)">
            <summary>
            Calculate and/or constrains a tile size
            </summary>
            <param name="width">The proposed tile width upon the call / tile width to use after the call.</param>
            <param name="height">The proposed tile height upon the call / tile height to use after the call.</param>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffErrorHandler">
            <summary>
            Default error handler implementation.
            </summary>
            <remarks>
            <para><b>TiffErrorHandler</b> provides error and warning handling methods that write an
            error or a warning messages to the <see cref="P:System.Console.Error"/>.
            </para><para>
            Applications that desire to capture control in the event of an error or a warning should
            set their custom error and warning handler using <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetErrorHandler(BitMiracle.LibTiff.Classic.TiffErrorHandler)"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.ErrorHandler(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Handles an error by writing it text to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.ErrorHandlerExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Handles an error by writing it text to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="clientData">A client data.</param>
            <param name="method">The method where an error is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks><para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which an error is detected.
            </para><para>
            The <paramref name="clientData"/> parameter can be anything. Its value and meaning is
            defined by an application and not the library.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.WarningHandler(BitMiracle.LibTiff.Classic.Tiff,System.String,System.String,System.Object[])">
            <summary>
            Handles a warning by writing it text to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="method">The method where a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffErrorHandler.WarningHandlerExt(BitMiracle.LibTiff.Classic.Tiff,System.Object,System.String,System.String,System.Object[])">
            <summary>
            Handles a warning by writing it text to the <see cref="P:System.Console.Error"/>.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class. Can be <c>null</c>.</param>
            <param name="clientData">A client data.</param>
            <param name="method">The method where a warning is detected.</param>
            <param name="format">A composite format string (see Remarks).</param>
            <param name="args">An object array that contains zero or more objects to format.</param>
            <remarks><para>
            The <paramref name="format"/> is a composite format string that uses the same format as
            <see cref="Overload:System.String.Format"/> method. The <paramref name="method"/> parameter, if
            not <c>null</c>, is printed before the message; it typically is used to identify the
            method in which a warning is detected.
            </para><para>
            The <paramref name="clientData"/> parameter can be anything. Its value and meaning is
            defined by an application and not the library.
            </para></remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffFieldInfo">
            <summary>
            Represents a TIFF field information.
            </summary>
            <remarks>
            <b>TiffFieldInfo</b> describes a field. It provides information about field name, type,
            number of values etc.
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable">
            <summary>
            marker for variable length tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp">
            <summary>
            marker for SamplesPerPixel-bound tags
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2">
            <summary>
            marker for integer variable length tags
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffFieldInfo.#ctor(BitMiracle.LibTiff.Classic.TiffTag,System.Int16,System.Int16,BitMiracle.LibTiff.Classic.TiffType,System.Int16,System.Boolean,System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffFieldInfo"/> class.
            </summary>
            <param name="tag">The tag to describe.</param>
            <param name="readCount">The number of values to read when reading field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable"/>, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2"/>.</param>
            <param name="writeCount">The number of values to write when writing field information
            or one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable"/>, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2"/>.</param>
            <param name="type">The type of the field value.</param>
            <param name="bit">Index of the bit to use in "Set Fields Vector" when this instance
            is merged into field info collection. Take a look at <see cref="T:BitMiracle.LibTiff.Classic.FieldBit"/> class.</param>
            <param name="okToChange">If true, then it is permissible to set the tag's value even
            after writing has commenced.</param>
            <param name="passCount">If true, then number of value elements should be passed to
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])"/> method as second parameter (right after tag type AND
            before value itself).</param>
            <param name="name">The name (description) of the tag this instance describes.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffFieldInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Tag">
            <summary>
            The tag described by this instance.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.ReadCount">
            <summary>
            Number of values to read when reading field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable"/>, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2"/>.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.WriteCount">
            <summary>
            Number of values to write when writing field information or
            one of <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable"/>, <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Spp"/> and <see cref="F:BitMiracle.LibTiff.Classic.TiffFieldInfo.Variable2"/>.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Type">
            <summary>
            Type of the field values.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Bit">
            <summary>
            Index of the bit to use in "Set Fields Vector" when this instance
            is merged into field info collection. Take a look at <see cref="T:BitMiracle.LibTiff.Classic.FieldBit"/> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.OkToChange">
            <summary>
            If true, then it is permissible to set the tag's value even after writing has commenced.
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.PassCount">
            <summary>
            If true, then number of value elements should be passed to <see cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])"/>
            method as second parameter (right after tag type AND before values itself).
            </summary>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffFieldInfo.Name">
            <summary>
            The name (or description) of the tag this instance describes.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage">
            <summary>
            RGBA-style image support. Provides methods for decoding images into RGBA (or other) format.
            </summary>
            <remarks>
            <para>
            <b>TiffRgbaImage</b> provide a high-level interface through which TIFF images may be read
            into memory. Images may be strip- or tile-based and have a variety of different
            characteristics: bits/sample, samples/pixel, photometric, etc. The target raster format
            can be customized to a particular application's needs by installing custom methods that
            manipulate image data according to application requirements.
            </para><para>
            The default usage for this class: check if an image can be processed using
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.RGBAImageOK(System.String@)"/>, construct an instance of
            <b>TiffRgbaImage</b> using <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)"/> and then read and decode an image into a
            target raster using <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)"/>. <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)"/> can be called
            multiple times to decode an image using different state parameters. If multiple images
            are to be displayed and there is not enough space for each of the decoded rasters,
            multiple instances of <b>TiffRgbaImage</b> can be managed and then calls can be made to
            <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)"/> as needed to display an image.</para>
            <para>
            To use the core support for reading and processing TIFF images, but write the resulting
            raster data in a different format one need only override the "put methods" used to store
            raster data. These methods are initially setup by <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)"/> to point to methods
            that pack raster data in the default ABGR pixel format. Two different methods are used
            according to the physical organization of the image data in the file: one for
            <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.CONTIG (packed samples),
            and another for <see cref="F:BitMiracle.LibTiff.Classic.TiffTag.PLANARCONFIG"/> = <see cref="T:BitMiracle.LibTiff.Classic.PlanarConfig"/>.SEPARATE
            (separated samples). Note that this mechanism can be used to transform the data before 
            storing it in the raster. For example one can convert data to colormap indices for display
            on a colormap display.</para><para>
            To setup custom "put" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig"/> property for contiguously
            packed samples and/or <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate"/> property for separated samples.</para>
            <para>
            The methods of <b>TiffRgbaImage</b> support the most commonly encountered flavors of TIFF.
            It is possible to extend this support by overriding the "get method" invoked by
            <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)"/> to read TIFF image data. Details of doing this are a bit involved,
            it is best to make a copy of an existing get method and modify it to suit the needs of an
            application. To setup custom "get" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get"/> property.</para>
            </remarks>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.tif">
            <summary>
            image handle
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.stoponerr">
            <summary>
            stop on read error
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.isContig">
            <summary>
            data is packed/separate
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.alpha">
            <summary>
            type of alpha data present
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.width">
            <summary>
            image width
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.height">
            <summary>
            image height
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.bitspersample">
            <summary>
            image bits/sample
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.samplesperpixel">
            <summary>
            image samples/pixel
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.orientation">
            <summary>
            image orientation
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.req_orientation">
            <summary>
            requested orientation
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.photometric">
            <summary>
            image photometric interp
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.redcmap">
            <summary>
            colormap pallete
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.Map">
            <summary>
            sample mapping array
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.BWmap">
            <summary>
            black and white map
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.PALmap">
            <summary>
            palette image map
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.ycbcr">
            <summary>
            YCbCr conversion state
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffRgbaImage.cielab">
            <summary>
            CIE L*a*b conversion state
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContigDelegate">
            <summary>
            Delegate for "put" method (the method that is called to pack pixel data in the raster)
            used when converting contiguously packed samples.
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="rasterOffset">The zero-based byte offset in <paramref name="raster"/> at
            which to begin storing decoded bytes.</param>
            <param name="rasterShift">The value that should be added to
            <paramref name="rasterOffset"/> after each row processed.</param>
            <param name="x">The x-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="y">The y-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="width">The block width.</param>
            <param name="height">The block height.</param>
            <param name="buffer">The buffer with image data.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin reading image bytes.</param>
            <param name="bufferShift">The value that should be added to <paramref name="offset"/>
            after each row processed.</param>
            <remarks><para>
            The image reading and conversion methods invoke "put" methods to copy/image/whatever
            tiles of raw image data. A default set of methods is provided to convert/copy raw
            image data to 8-bit packed ABGR format rasters. Applications can supply alternate
            methods that unpack the data into a different format or, for example, unpack the data
            and draw the unpacked raster on the display.
            </para><para>
            To setup custom "put" method for contiguously packed samples please use
            <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig"/> property.</para>
            <para>
            The <paramref name="bufferShift"/> is usually 0. It is greater than 0 if width of strip
            being converted is greater than image width or part of the tile being converted is
            outside the image (may be true for tiles on the right and bottom edge of the image).
            In other words, <paramref name="bufferShift"/> is used to make up for any padding on
            the end of each line of the buffer with image data.
            </para><para>
            The <paramref name="rasterShift"/> is 0 if width of tile being converted is equal to
            image width and image data should not be flipped vertically. In other circumstances
            <paramref name="rasterShift"/> is used to make up for any padding on the end of each
            line of the raster and/or for flipping purposes.
            </para></remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparateDelegate">
            <summary>
            Delegate for "put" method (the method that is called to pack pixel data in the raster)
            used when converting separated samples.
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="rasterOffset">The zero-based byte offset in <paramref name="raster"/> at
            which to begin storing decoded bytes.</param>
            <param name="rasterShift">The value that should be added to
            <paramref name="rasterOffset"/> after each row processed.</param>
            <param name="x">The x-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="y">The y-coordinate of the first pixel in block of pixels to be decoded.</param>
            <param name="width">The block width.</param>
            <param name="height">The block height.</param>
            <param name="buffer">The buffer with image data.</param>
            <param name="offset1">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin reading image bytes that constitute first sample plane.</param>
            <param name="offset2">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin reading image bytes that constitute second sample plane.</param>
            <param name="offset3">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin reading image bytes that constitute third sample plane.</param>
            <param name="offset4">The zero-based byte offset in <paramref name="buffer"/> at
            which to begin reading image bytes that constitute fourth sample plane.</param>
            <param name="bufferShift">The value that should be added to <paramref name="offset1"/>,
            <paramref name="offset2"/>, <paramref name="offset3"/> and <paramref name="offset4"/>
            after each row processed.</param>
            <remarks><para>
            The image reading and conversion methods invoke "put" methods to copy/image/whatever
            tiles of raw image data. A default set of methods is provided to convert/copy raw
            image data to 8-bit packed ABGR format rasters. Applications can supply alternate
            methods that unpack the data into a different format or, for example, unpack the data
            and draw the unpacked raster on the display.
            </para><para>
            To setup custom "put" method for separated samples please use
            <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate"/> property.</para>
            <para>
            The <paramref name="bufferShift"/> is usually 0. It is greater than 0 if width of strip
            being converted is greater than image width or part of the tile being converted is
            outside the image (may be true for tiles on the right and bottom edge of the image).
            In other words, <paramref name="bufferShift"/> is used to make up for any padding on
            the end of each line of the buffer with image data.
            </para><para>
            The <paramref name="rasterShift"/> is 0 if width of tile being converted is equal to
            image width and image data should not be flipped vertically. In other circumstances
            <paramref name="rasterShift"/> is used to make up for any padding on the end of each
            line of the raster and/or for flipping purposes.
            </para></remarks>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetDelegate">
            <summary>
            Delegate for "get" method (the method that is called to produce RGBA raster).
            </summary>
            <param name="img">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> class.</param>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="offset">The zero-based byte offset in <paramref name="raster"/> at which
            to begin storing decoded bytes.</param>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <returns><c>true</c> if the image was successfully read and decoded; otherwise,
            <c>false</c>.</returns>
            <remarks><para>
            A default set of methods is provided to read and convert/copy raw image data to 8-bit
            packed ABGR format rasters. Applications can supply alternate method for this.
            </para><para>
            To setup custom "get" method please use <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get"/> property.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.Create(BitMiracle.LibTiff.Classic.Tiff,System.Boolean,System.String@)">
            <summary>
            Creates new instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> class.
            </summary>
            <param name="tif">
            The instance of the <see cref="N:BitMiracle.LibTiff.Classic"/> class used to retrieve
            image data.
            </param>
            <param name="stopOnError">
            if set to <c>true</c> then an error will terminate the conversion; otherwise "get"
            methods will continue processing data until all the possible data in the image have
            been requested.
            </param>
            <param name="errorMsg">The error message (if any) gets placed here.</param>
            <returns>
            New instance of the <see cref="T:BitMiracle.LibTiff.Classic.TiffRgbaImage"/> class if the image specified
            by <paramref name="tif"/> can be converted to RGBA format; otherwise, <c>null</c> is
            returned and <paramref name="errorMsg"/> contains the reason why it is being
            rejected.
            </returns>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.IsContig">
            <summary>
            Gets a value indicating whether image data has contiguous (packed) or separated samples.
            </summary>
            <value><c>true</c> if this image data has contiguous (packed) samples; otherwise,
            <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Alpha">
            <summary>
            Gets the type of alpha data present.
            </summary>
            <value>The type of alpha data present.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Width">
            <summary>
            Gets the image width.
            </summary>
            <value>The image width.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Height">
            <summary>
            Gets the image height.
            </summary>
            <value>The image height.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.BitsPerSample">
            <summary>
            Gets the image bits per sample count.
            </summary>
            <value>The image bits per sample count.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.SamplesPerPixel">
            <summary>
            Gets the image samples per pixel count.
            </summary>
            <value>The image samples per pixel count.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Orientation">
            <summary>
            Gets the image orientation.
            </summary>
            <value>The image orientation.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation">
            <summary>
            Gets or sets the requested orientation.
            </summary>
            <value>The requested orientation.</value>
            <remarks>The <see cref="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)"/> method uses this value when placing converted
            image data into raster buffer.</remarks>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Photometric">
            <summary>
            Gets the photometric interpretation of the image data.
            </summary>
            <value>The photometric interpretation of the image data.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get">
            <summary>
            Gets or sets the "get" method (the method that is called to produce RGBA raster).
            </summary>
            <value>The "get" method.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig">
            <summary>
            Gets or sets the "put" method (the method that is called to pack pixel data in the
            raster) used when converting contiguously packed samples.
            </summary>
            <value>The "put" method used when converting contiguously packed samples.</value>
        </member>
        <member name="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate">
            <summary>
            Gets or sets the "put" method (the method that is called to pack pixel data in the
            raster) used when converting separated samples.
            </summary>
            <value>The "put" method used when converting separated samples.</value>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GetRaster(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Reads the underlaying TIFF image and decodes it into RGBA format raster.
            </summary>
            <param name="raster">The raster (the buffer to place decoded image data to).</param>
            <param name="offset">The zero-based byte offset in <paramref name="raster"/> at which
            to begin storing decoded bytes.</param>
            <param name="width">The raster width.</param>
            <param name="height">The raster height.</param>
            <returns><c>true</c> if the image was successfully read and decoded; otherwise,
            <c>false</c>.</returns>
            <remarks><para>
            <b>GetRaster</b> reads image into memory using current "get" (<see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.Get"/>) method,
            storing the result in the user supplied RGBA <paramref name="raster"/> using one of
            the "put" (<see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutContig"/> or <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.PutSeparate"/>) methods. The raster
            is assumed to be an array of <paramref name="width"/> times <paramref name="height"/>
            32-bit entries, where <paramref name="width"/> must be less than or equal to the width
            of the image (<paramref name="height"/> may be any non-zero size). If the raster
            dimensions are smaller than the image, the image data is cropped to the raster bounds.
            If the raster height is greater than that of the image, then the image data placement
            depends on the value of <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation"/> property. Note that the raster is
            assumed to be organized such that the pixel at location (x, y) is
            <paramref name="raster"/>[y * width + x]; with the raster origin specified by the
            value of <see cref="P:BitMiracle.LibTiff.Classic.TiffRgbaImage.ReqOrientation"/> property.
            </para><para>
            Raster pixels are 8-bit packed red, green, blue, alpha samples. The 
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetR(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetG(System.Int32)"/>, <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetB(System.Int32)"/>, and
            <see cref="M:BitMiracle.LibTiff.Classic.Tiff.GetA(System.Int32)"/> should be used to access individual samples. Images without
            Associated Alpha matting information have a constant Alpha of 1.0 (255).
            </para><para>
            <b>GetRaster</b> converts non-8-bit images by scaling sample values. Palette,
            grayscale, bilevel, CMYK, and YCbCr images are converted to RGB transparently.
            Raster pixels are returned uncorrected by any colorimetry information present in
            the directory.
            </para><para>
            Samples must be either 1, 2, 4, 8, or 16 bits. Colorimetric samples/pixel must be
            either 1, 3, or 4 (i.e. SamplesPerPixel minus ExtraSamples).
            </para><para>
            Palette image colormaps that appear to be incorrectly written as 8-bit values are
            automatically scaled to 16-bits.
            </para><para>
            All error messages are directed to the current error handler.
            </para></remarks>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.CMAP(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Palette images with &lt;= 8 bits/sample are handled with a table to avoid lots of shifts
            and masks. The table is setup so that put*cmaptile (below) can retrieve 8 / bitspersample
            pixel values simply by indexing into the table with one number.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.GREY(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Greyscale images with less than 8 bits/sample are handled with a table to avoid lots
            of shifts and masks. The table is setup so that put*bwtile (below) can retrieve
            8 / bitspersample pixel values simply by indexing into the table with one number.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtTileContig(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an tile-organized image that has
            PlanarConfiguration contiguous if SamplesPerPixel > 1
             or
            SamplesPerPixel == 1
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtTileSeparate(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get an tile-organized image that has
            SamplesPerPixel > 1
            PlanarConfiguration separated
            We assume that all such images are RGB.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtStripContig(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get a strip-organized image that has 
            PlanarConfiguration contiguous if SamplesPerPixel > 1
             or
            SamplesPerPixel == 1
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.gtStripSeparate(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Get a strip-organized image with
             SamplesPerPixel > 1
             PlanarConfiguration separated
            We assume that all such images are RGB.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.pickContigCase">
            <summary>
            Select the appropriate conversion routine for packed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.pickSeparateCase">
            <summary>
            Select the appropriate conversion routine for unpacked data.
            NB: we assume that unpacked single channel data is directed to the "packed routines.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.buildMap">
            <summary>
            Construct any mapping table used by the associated put method.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.setupMap">
            <summary>
            Construct a mapping table to convert from the range of the data samples to [0, 255] -
            for display. This process also handles inverting B&amp;W images when needed.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.YCbCrtoRGB(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            YCbCr -> RGB conversion and packing routines.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put8bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit palette => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put4bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            4-bit palette => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put2bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            2-bit palette => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put1bitcmaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            1-bit palette => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putgreytile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit greyscale => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putgreywithalphatile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit greyscale with alpha => colormap/RGBA
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put16bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit greyscale => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put1bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            1-bit bilevel => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put2bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            2-bit greyscale => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.put4bitbwtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            4-bit greyscale => colormap/RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples, no Map => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples => RGBA w/ associated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAcontig8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed samples => RGBA w/ unassociated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples => RGBA w/ associated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAcontig16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            16-bit packed samples => RGBA w/ unassociated alpha (known to have Map == null)
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAcontig8bitCMYKAtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYKA samples w/o Map => RGBA.
            NB: The conversion of CMYKA->RGBA is *very* crude.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bitCMYKtile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYK samples w/o Map => RGB.
            NB: The conversion of CMYK->RGB is *very* crude.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitCIELab(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CIE L*a*b 1976 samples => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr22tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 2,2 subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr21tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 2,1 subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr44tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,4 subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr42tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,2 subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr41tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 4,1 subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr11tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ no subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putcontig8bitYCbCr12tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ 1,2 subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples => RGBA w/ associated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAseparate8bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit unpacked samples => RGBA w/ unassociated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBAAseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples => RGBA w/ associated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBUAseparate16bittile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            16-bit unpacked samples => RGBA w/ unassociated alpha
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putseparate8bitYCbCr11tile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            8-bit packed YCbCr samples w/ no subsampling => RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffRgbaImage.putRGBcontig8bitCMYKMaptile(BitMiracle.LibTiff.Classic.TiffRgbaImage,System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            8-bit packed CMYK samples w/Map => RGB
            NB: The conversion of CMYK->RGB is *very* crude.
            </summary>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffStream">
            <summary>
            A stream used by the library for TIFF reading and writing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Read(System.Object,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the stream and advances the position within the stream
            by the number of bytes read.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="buffer">An array of bytes. When this method returns, the
            <paramref name="buffer"/> contains the specified byte array with the values between
            <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1)
            replaced by the bytes read from the current source.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin storing the data read from the current stream.</param>
            <param name="count">The maximum number of bytes to be read from the current stream.</param>
            <returns>The total number of bytes read into the <paramref name="buffer"/>. This can
            be less than the number of bytes requested if that many bytes are not currently
            available, or zero (0) if the end of the stream has been reached.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Write(System.Object,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position
            within this stream by the number of bytes written.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/>
            bytes from <paramref name="buffer"/> to the current stream.</param>
            <param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which
            to begin copying bytes to the current stream.</param>
            <param name="count">The number of bytes to be written to the current stream.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Seek(System.Object,System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter.</param>
            <param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the
            reference point used to obtain the new position.</param>
            <returns>The new position within the current stream.</returns>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Close(System.Object)">
            <summary>
            Closes the current stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffStream.Size(System.Object)">
            <summary>
            Gets the length in bytes of the stream.
            </summary>
            <param name="clientData">A client data (by default, an underlying stream).</param>
            <returns>The length of the stream in bytes.</returns>
        </member>
        <member name="T:BitMiracle.LibTiff.Classic.TiffTagMethods">
            <summary>
            Tiff tag methods.
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_VOID">
            <summary>
            untyped data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_INT">
            <summary>
            signed integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_UINT">
            <summary>
            unsigned integer data
            </summary>
        </member>
        <member name="F:BitMiracle.LibTiff.Classic.TiffTagMethods.DATATYPE_IEEEFP">
            <summary>
            IEEE floating point data
            </summary>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.SetField(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.TiffTag,BitMiracle.LibTiff.Classic.FieldValue[])">
            <summary>
            Sets the value(s) of a tag in a TIFF file/stream open for writing.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class.</param>
            <param name="tag">The tag.</param>
            <param name="value">The tag value(s).</param>
            <returns>
            <c>true</c> if tag value(s) were set successfully; otherwise, <c>false</c>.
            </returns>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.SetField(BitMiracle.LibTiff.Classic.TiffTag,System.Object[])"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.GetField(BitMiracle.LibTiff.Classic.Tiff,BitMiracle.LibTiff.Classic.TiffTag)">
            <summary>
            Gets the value(s) of a tag in an open TIFF file.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class.</param>
            <param name="tag">The tag.</param>
            <returns>The value(s) of a tag in an open TIFF file/stream as array of
            <see cref="T:BitMiracle.LibTiff.Classic.FieldValue"/> objects or <c>null</c> if there is no such tag set.</returns>
            <seealso cref="M:BitMiracle.LibTiff.Classic.Tiff.GetField(BitMiracle.LibTiff.Classic.TiffTag)"/>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.PrintDir(BitMiracle.LibTiff.Classic.Tiff,System.IO.Stream,BitMiracle.LibTiff.Classic.TiffPrintFlags)">
            <summary>
            Prints formatted description of the contents of the current directory to the
            specified stream using specified print (formatting) options.
            </summary>
            <param name="tif">An instance of the <see cref="T:BitMiracle.LibTiff.Classic.Tiff"/> class.</param>
            <param name="stream">The stream to print to.</param>
            <param name="flags">The print (formatting) options.</param>
        </member>
        <member name="M:BitMiracle.LibTiff.Classic.TiffTagMethods.setExtraSamples(BitMiracle.LibTiff.Classic.Internal.TiffDirectory,System.Int32@,BitMiracle.LibTiff.Classic.FieldValue[])">
            <summary>
            Install extra samples information.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.DensityUnit">
            <summary>
            The unit of density.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">
            <summary>
            Unknown density
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsInch">
            <summary>
            Dots/inch
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.DensityUnit.DotsCm">
            <summary>
            Dots/cm
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.bitread_perm_state">
            <summary>
            Bitreading state saved across MCUs
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer">
            <summary>
            Encapsulates buffer of image samples for one color component
            When provided with funny indices (see jpeg_d_main_controller for 
            explanation of what it is) uses them for non-linear row access.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl">
            <summary>
            Derived data constructed for each Huffman table
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder">
            <summary>
            Expanded entropy decoder object for Huffman decoding.
            
            The savable_state subrecord contains fields that change within an MCU,
            but must not be updated permanently until we complete the MCU.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.start_pass">
            <summary>
            Initialize for a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_full(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, full-size blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_sub(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            Decode one MCU's worth of Huffman-compressed coefficients, partial blocks.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.decode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[])">
            <summary>
            MCU decoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component,
            although the spec is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.process_restart">
            <summary>
            Check for a restart marker and resynchronize decoder.
            Returns false if must suspend.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_decoder.jpeg_make_d_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.d_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder">
            <summary>
            Expanded entropy encoder object for Huffman encoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.start_pass(System.Boolean)">
            <summary>
            Initialize for a Huffman-compressed scan.
            If gather_statistics is true, we do not output anything during the scan,
            just count the Huffman symbols used and generate Huffman code tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_huff(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Encode and output one MCU's worth of Huffman-compressed coefficients.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_huff">
            <summary>
            Finish up at the end of a Huffman-compressed scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_gather(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            Trial-encode one MCU's worth of Huffman-compressed coefficients.
            No data is actually output, so no suspension return is possible.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.finish_pass_gather">
            <summary>
            Finish up a statistics-gathering pass and create the new Huffman tables.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_one_block(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int16[],System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl)">
            <summary>
            Encode a single block's worth of coefficients
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.htest_one_block(System.Int16[],System.Int32,System.Int64[],System.Int64[])">
            <summary>
            Huffman coding optimization.
            
            We first scan the supplied data and count the number of uses of each symbol
            that is to be Huffman-coded. (This process MUST agree with the code above.)
            Then we build a Huffman coding tree for the observed counts.
            Symbols which are not needed at all for the particular image are not
            assigned any code, which saves space in the DHT marker as well as in
            the compressed data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32,System.Int32)">
            <summary>
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits; return true if successful, false if must suspend
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_bits_e(System.Int32,System.Int32)">
            <summary>
            Outputting bits to the file
            
            Only the right 24 bits of put_buffer are used; the valid bits are
            left-justified in this part.  At most 16 bits can be passed to emit_bits
            in one call, and we never retain more than 7 bits in put_buffer
            between calls, so 24 bits are sufficient.
            </summary>
            Emit some bits, unless we are in gather mode
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.emit_restart_s(BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.savable_state,System.Int32)">
            <summary>
            Emit a restart marker and resynchronize predictions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            IRIGHT_SHIFT is like RIGHT_SHIFT, but works on int rather than int.
            We assume that int right shift is unsigned if int right shift is,
            which should be safe.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_first(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC initial scan (either spectral selection,
            or first pass of successive approximation).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_DC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for DC successive approximation refinement scan.
            Note: we assume such scans can be multi-component, although the spec
            is not very clear on the point.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.encode_mcu_AC_refine(BitMiracle.LibJpeg.Classic.JBLOCK[][])">
            <summary>
            MCU encoding for AC successive approximation refinement scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_make_c_derived_tbl(System.Boolean,System.Int32,BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.c_derived_tbl@)">
            <summary>
            Expand a Huffman table definition into the derived format
            Compute the derived values for a Huffman table.
            This routine also performs some validation checks on the table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.huff_entropy_encoder.jpeg_gen_optimal_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL,System.Int64[])">
            <summary>
            Generate the best Huffman code table for the given counts, fill htbl.
            
            The JPEG standard requires that no symbol be assigned a codeword of all
            one bits (so that padding bits added at the end of a compressed segment
            can't look like a valid code).  Because of the canonical ordering of
            codewords, this just means that there must be an unused slot in the
            longest codeword length category.  Section K.2 of the JPEG spec suggests
            reserving such a slot by pretending that symbol 256 is a valid symbol
            with count 1.  In theory that's not optimal; giving it count zero but
            including it in the symbol set anyway should give a better Huffman code.
            But the theoretically better code actually seems to come out worse in
            practice, because it produces more all-ones bytes (which incur stuffed
            zero bytes in the final file).  In any case the difference is tiny.
            
            The JPEG standard requires Huffman codes to be no more than 16 bits long.
            If some symbols have a very small but nonzero probability, the Huffman tree
            must be adjusted to meet the code length restriction.  We currently use
            the adjustment method suggested in JPEG section K.2.  This method is *not*
            optimal; it may not choose the best possible limited-length code.  But
            typically only very-low-frequency symbols will be given less-than-optimal
            lengths, so the code is almost optimal.  Experimental comparisons against
            an optimal limited-length-code algorithm indicate that the difference is
            microscopic --- usually less than a hundredth of a percent of total size.
            So the extra complexity of an optimal algorithm doesn't seem worthwhile.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order7">
            zz to natural order for 7x7 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order6">
            zz to natural order for 6x6 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order5">
            zz to natural order for 5x5 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order4">
            zz to natural order for 4x4 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order3">
            zz to natural order for 3x3 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_natural_order2">
            zz to natural order for 2x2 block
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jpeg_aritab">
            Arithmetic coding probability estimation tables
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jdiv_round_up(System.Int64,System.Int64)">
            <summary>
            Compute a/b rounded up to next integer, ie, ceil(a/b)
            Assumes a >= 0, b > 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jround_up(System.Int32,System.Int32)">
            <summary>
            Compute a rounded up to next multiple of b, ie, ceil(a/b)*b
            Assumes a >= 0, b > 0
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.JpegUtils.jcopy_sample_rows(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer,System.Int32,System.Byte[][],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy some rows of samples from one place to another.
            num_rows rows are copied from input_array[source_row++]
            to output_array[dest_row++]; these areas may overlap for duplication.
            The source and destination arrays must be at least as wide as num_cols.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.color_convert">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            
            Note that we change from the application's interleaved-pixel format
            to our internal noninterleaved, one-plane-per-component format.
            The input buffer is therefore three times as wide as the output buffer.
            
            A starting row offset is provided only for the output buffer.  The caller
            can easily adjust the passed input_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_start">
            <summary>
            Initialize for RGB->YCC colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_ycc_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            RGB -&gt; YCbCr conversion: most common case
            YCbCr is defined per CCIR 601-1, except that Cb and Cr are
            normalized to the range 0..MAXJSAMPLE rather than -0.5 .. 0.5.
            The conversion equations to be implemented are therefore
            Y  =  0.29900 * R + 0.58700 * G + 0.11400 * B
            Cb = -0.16874 * R - 0.33126 * G + 0.50000 * B  + CENTERJSAMPLE
            Cr =  0.50000 * R - 0.41869 * G - 0.08131 * B  + CENTERJSAMPLE
            (These numbers are derived from TIFF 6.0 section 21, dated 3-June-92.)
            To avoid floating-point arithmetic, we represent the fractional constants
            as integers scaled up by 2^16 (about 4 digits precision); we have to divide
            the products by 2^16, with appropriate rounding, to get the correct answer.
            For even more speed, we avoid doing any multiplications in the inner loop
            by precalculating the constants times R,G,B for all possible values.
            For 8-bit JSAMPLEs this is very reasonable (only 256 entries per table);
            for 12-bit samples it is still acceptable.  It's not very reasonable for
            16-bit samples, but if you want lossless storage you shouldn't be changing
            colorspace anyway.
            The CENTERJSAMPLE offsets and the rounding fudge-factor of 0.5 are included
            in the tables to save adding them separately in the inner loop.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.rgb_gray_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles RGB->grayscale conversion, which is the same
            as the RGB->Y portion of RGB->YCbCr.
            We assume rgb_ycc_start has been called (we only use the Y tables).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.cmyk_ycck_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles Adobe-style CMYK->YCCK conversion,
            where we convert R=1-C, G=1-M, and B=1-Y to YCbCr using the same
            conversion as above, while passing K (black) unchanged.
            We assume rgb_ycc_start has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.grayscale_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles grayscale output with no conversion.
            The source can be either plain grayscale or YCC (since Y == gray).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_converter.null_convert(System.Byte[][],System.Int32,System.Byte[][][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the JPEG colorspace.
            This version handles multi-component colorspaces without conversion.
            We assume input_components == num_components.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter">
            <summary>
            Colorspace conversion
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for output colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.color_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert some rows of samples to the output colorspace.
            
            Note that we change from noninterleaved, one-plane-per-component format
            to interleaved-pixel format.  The output buffer is therefore three times
            as wide as the input buffer.
            A starting row offset is provided only for the input buffer.  The caller
            can easily adjust the passed output_buf value to accommodate any row
            offset required on that side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr->RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC->RGB colorspace conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_cmyk_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Adobe-style YCCK->CMYK conversion.
            We convert YCbCr to R=1-C, G=1-M, and B=1-Y using the same
            conversion as above, while passing K (black) unchanged.
            We assume build_ycc_rgb_table has been called.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.gray_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Convert grayscale to RGB: just duplicate the graylevel three times.
            This is provided to support applications that don't want to cope
            with grayscale as a separate case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.grayscale_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for grayscale: just copy the data.
            This also works for YCC -> grayscale conversion, in which
            we just copy the Y (luminance) component and ignore chrominance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.cmyk_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for CMYK -> RGB
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.ycck_rgb_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for YCCK -> RGB
            it's just a gybrid of YCCK -> CMYK and CMYK -> RGB conversions
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_deconverter.null_convert(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Color conversion for no colorspace change: just copy the data,
            converting from separate-planes to interleaved representation.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_color_quantizer">
            <summary>
            Color quantization or color precision reduction
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.prepare_for_pass">
            <summary>
            Per-pass setup.
            
            This is called at the beginning of each pass.  We determine which 
            modules will be active during this pass and give them appropriate 
            start_pass calls. 
            We also set is_last_pass to indicate whether any more passes will 
            be required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.pass_startup">
            <summary>
            Special start-of-pass hook.
            
            This is called by jpeg_write_scanlines if call_pass_startup is true.
            In single-pass processing, we need this hook because we don't want to
            write frame/scan headers during jpeg_start_compress; we want to let the
            application write COM markers etc. between jpeg_start_compress and the
            jpeg_write_scanlines loop.
            In multi-pass processing, this routine is not used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.finish_pass">
            <summary>
            Finish up at end of pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_comp_master.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] are already set
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_coef_controller">
            <summary>
            Coefficient buffer control
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_main_controller.process_data(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This routine handles the simple pass-through mode,
            where we have only a strip buffer.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller">
            <summary>
            Compression preprocessing (downsampling input buffer control).
            
            For the simple (no-context-row) case, we just need to buffer one
            row group's worth of pixels for the downsampling step.  At the bottom of
            the image, we pad to a full row group by replicating the last pixel row.
            The downsampler's last output row is then replicated if needed to pad
            out to a full iMCU row.
            
            When providing context rows, we must buffer three row groups' worth of
            pixels.  Three row groups are physically allocated, but the row pointer
            arrays are made five row groups high, with the extra pointers above and
            below "wrapping around" to point to the last and first real row groups.
            This allows the downsampler to access the proper context rows.
            At the top and bottom of the image, we create dummy context rows by
            copying the first or last real pixel row.  This copying could be avoided
            by pointer hacking as is done in jdmainct.c, but it doesn't seem worth the
            trouble on the compression side.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.create_context_buffer">
            <summary>
            Create the wrapped-around downsampling input buffer needed for context mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_WithoutContext(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the simple no-context case.
            
            Preprocessor output data is counted in "row groups".  A row group
            is defined to be v_samp_factor sample rows of each component.
            Downsampling will produce this much data from each max_v_samp_factor
            input rows.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.pre_process_context(System.Byte[][],System.Int32@,System.Int32,System.Byte[][][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the context case.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_c_prep_controller.expand_bottom_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand an image vertically from height input_rows to height output_rows,
            by duplicating the bottom row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master">
            <summary>
            Master control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_for_output_pass">
            <summary>
            Per-pass setup.
            This is called at the beginning of each output pass.  We determine which
            modules will be active during this pass and give them appropriate
            start_pass calls.  We also set is_dummy_pass to indicate whether this
            is a "real" output pass or a dummy pass for color quantization.
            (In the latter case, we will crank the pass to completion.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.finish_output_pass">
            <summary>
            Finish up at end of an output pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.master_selection">
            <summary>
            Master selection of decompression modules.
            This is done once at jpeg_start_decompress time.  We determine
            which modules will be used and give them appropriate initialization calls.
            We also initialize the decompressor input side to begin consuming data.
            
            Since jpeg_read_header has finished, we know what is in the SOF
            and (first) SOS markers.  We also have all the application parameter
            settings.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_decomp_master.prepare_range_limit_table">
            <summary>
            Allocate and fill in the sample_range_limit table.
            
            Several decompression processes need to range-limit values to the range
            0..MAXJSAMPLE; the input value may fall somewhat outside this range
            due to noise introduced by quantization, roundoff error, etc. These
            processes are inner loops and need to be as fast as possible. On most
            machines, particularly CPUs with pipelines or instruction prefetch,
            a (subscript-check-less) C table lookup
                x = sample_range_limit[x];
            is faster than explicit tests
            <c>
                if (x &amp; 0)
                   x = 0;
                else if (x > MAXJSAMPLE)
                   x = MAXJSAMPLE;
            </c>
            These processes all use a common table prepared by the routine below.
            
            For most steps we can mathematically guarantee that the initial value
            of x is within 2*(MAXJSAMPLE+1) of the legal range, so a table running
            from -2*(MAXJSAMPLE+1) to 3*MAXJSAMPLE+2 is sufficient.But for the
            initial limiting step(just after the IDCT), a wildly out-of-range value
            is possible if the input data is corrupt.To avoid any chance of indexing
            off the end of memory and getting a bad-pointer trap, we perform the
            post-IDCT limiting thus:
                <c>x = (sample_range_limit - SUBSET)[(x + CENTER) &amp; MASK];</c>
            where MASK is 2 bits wider than legal sample data, ie 10 bits for 8-bit
            samples.  Under normal circumstances this is more than enough range and
            a correct output will be generated; with bogus input data the mask will
            cause wraparound, and we will safely generate a bogus-but-in-range output.
            For the post-IDCT step, we want to convert the data from signed to unsigned
            representation by adding CENTERJSAMPLE at the same time that we limit it.
            This is accomplished with SUBSET = CENTER - CENTERJSAMPLE.
            
            Note that the table is allocated in near data space on PCs; it's small
            enough and used often enough to justify this.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler">
            <summary>
            Downsampling
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.downsample(System.Byte[][][],System.Int32,System.Byte[][][],System.Int32)">
            <summary>
            Do downsampling for a whole row group (all components).
            
            In this version we simply downsample each component independently.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.int_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            One row group is processed per call.
            This version handles arbitrary integral sampling ratios, without smoothing.
            Note that this version is not actually used for customary sampling ratios.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v1_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the common case of 2:1 horizontal and 1:1 vertical,
            without smoothing.
            
            A note about the "bias" calculations: when rounding fractional values to
            integer, we do not want to always round 0.5 up to the next integer.
            If we did that, we'd introduce a noticeable bias towards larger values.
            Instead, this code is arranged so that 0.5 will be rounded up or down at
            alternate pixel locations (a simple ordered dither pattern).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            without smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.h2v2_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the standard case of 2:1 horizontal and 2:1 vertical,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.fullsize_smooth_downsample(System.Int32,System.Byte[][],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Downsample pixel values of a single component.
            This version handles the special case of a full-size component,
            with smoothing.  One row of context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_downsampler.expand_right_edge(System.Byte[][],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Expand a component horizontally from width input_cols to width output_cols,
            by duplicating the rightmost samples.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller">
            <summary>
            Coefficient buffer control
            
            This code applies interblock smoothing as described by section K.8
            of the JPEG standard: the first 5 AC coefficients are estimated from
            the DC values of a DCT block and its 8 neighboring blocks.
            We apply smoothing only for progressive JPEG decoding, and only if
            the coefficients it can estimate are not yet known to full precision.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_input_pass">
            <summary>
            Initialize for an input processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.consume_data">
            <summary>
            Consume input data and store it in the full-image coefficient buffer.
            We read as much as one fully interleaved MCU row ("iMCU" row) per call,
            ie, v_samp_factor block rows for each component in the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_output_pass">
            <summary>
            Initialize for an output processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_onepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the single-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Input and output must run in lockstep since we have only a one-MCU buffer.
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_data_ordinary(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Decompress and return some data in the multi-pass case.
            Always attempts to emit one fully interleaved MCU row ("iMCU" row).
            Return value is JPEG_ROW_COMPLETED, JPEG_SCAN_COMPLETED, or JPEG_SUSPENDED.
            
            NB: output_buf contains a plane for each component in image.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.decompress_smooth_data(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[])">
            <summary>
            Variant of decompress_data for use when doing block smoothing.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.smoothing_ok">
            <summary>
            Determine whether block smoothing is applicable and safe.
            We also latch the current states of the coef_bits[] entries for the
            AC coefficients; otherwise, if the input side of the decompressor
            advances into a new scan, we might think the coefficients are known
            more accurately than they really are.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row (input side)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller">
            <summary>
            Main buffer control (downsampled-data buffer)
            
            In the current system design, the main buffer need never be a full-image
            buffer; any full-height buffers will be found inside the coefficient or
            postprocessing controllers.  Nonetheless, the main controller is not
            trivial.  Its responsibility is to provide context rows for upsampling/
            rescaling, and doing this in an efficient fashion is a bit tricky.
            
            Postprocessor input data is counted in "row groups".  A row group
            is defined to be (v_samp_factor * DCT_scaled_size / min_DCT_scaled_size)
            sample rows of each component.  (We require DCT_scaled_size values to be
            chosen such that these numbers are integers.  In practice DCT_scaled_size
            values will likely be powers of two, so we actually have the stronger
            condition that DCT_scaled_size / min_DCT_scaled_size is an integer.)
            Upsampling will typically produce max_v_samp_factor pixel rows from each
            row group (times any additional scale factor that the upsampler is
            applying).
            
            The coefficient controller will deliver data to us one iMCU row at a time;
            each iMCU row contains v_samp_factor * DCT_scaled_size sample rows, or
            exactly min_DCT_scaled_size row groups.  (This amount of data corresponds
            to one row of MCUs when the image is fully interleaved.)  Note that the
            number of sample rows varies across components, but the number of row
            groups does not.  Some garbage sample rows may be included in the last iMCU
            row at the bottom of the image.
            
            Depending on the vertical scaling algorithm used, the upsampler may need
            access to the sample row(s) above and below its current input row group.
            The upsampler is required to set need_context_rows true at global selection
            time if so.  When need_context_rows is false, this controller can simply
            obtain one iMCU row at a time from the coefficient controller and dole it
            out as row groups to the postprocessor.
            
            When need_context_rows is true, this controller guarantees that the buffer
            passed to postprocessing contains at least one row group's worth of samples
            above and below the row group(s) being processed.  Note that the context
            rows "above" the first passed row group appear at negative row offsets in
            the passed buffer.  At the top and bottom of the image, the required
            context rows are manufactured by duplicating the first or last real sample
            row; this avoids having special cases in the upsampling inner loops.
            
            The amount of context is fixed at one row group just because that's a
            convenient number for this controller to work with.  The existing
            upsamplers really only need one sample row of context.  An upsampler
            supporting arbitrary output rescaling might wish for more than one row
            group of context when shrinking the image; tough, we don't handle that.
            (This is justified by the assumption that downsizing will be handled mostly
            by adjusting the DCT_scaled_size values, so that the actual scale factor at
            the upsample step needn't be much less than one.)
            
            To provide the desired context, we have to retain the last two row groups
            of one iMCU row while reading in the next iMCU row.  (The last row group
            can't be processed until we have another row group for its below-context,
            and so we have to save the next-to-last group too for its above-context.)
            We could do this most simply by copying data around in our buffer, but
            that'd be very slow.  We can avoid copying any data by creating a rather
            strange pointer structure.  Here's how it works.  We allocate a workspace
            consisting of M+2 row groups (where M = min_DCT_scaled_size is the number
            of row groups per iMCU row).  We create two sets of redundant pointers to
            the workspace.  Labeling the physical row groups 0 to M+1, the synthesized
            pointer lists look like this:
                              M+1                          M-1
                              master pointer --> 0         master pointer --> 0
                              1                            1
                              ...                          ...
                              M-3                          M-3
                              M-2                           M
                              M-1                          M+1
                               M                           M-2
                              M+1                          M-1
                               0                            0
            We read alternate iMCU rows using each master pointer; thus the last two
            row groups of the previous iMCU row remain un-overwritten in the workspace.
            The pointer lists are set up so that the required context rows appear to
            be adjacent to the proper places when we pass the pointer lists to the
            upsampler.
            
            The above pictures describe the normal state of the pointer lists.
            At top and bottom of the image, we diddle the pointer lists to duplicate
            the first or last sample row as necessary (this is cheaper than copying
            sample rows around).
            
            This scheme breaks down if M less than 2, ie, min_DCT_scaled_size is 1.  In that
            situation each iMCU row provides only one row group so the buffering logic
            must be different (eg, we must read two iMCU rows before we can emit the
            first row group).  For now, we simply do not support providing context
            rows when min_DCT_scaled_size is 1.  That combination seems unlikely to
            be worth providing --- if someone wants a 1/8th-size preview, they probably
            want it quick and dirty, so a context-free upsampler is sufficient.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_simple_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the simple case where no context is required.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_context_main(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            This handles the case where context rows must be provided.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.process_data_crank_post(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data.
            Final pass of two-pass quantization: just call the postprocessor.
            Source data will be the postprocessor controller's internal buffer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.alloc_funny_pointers">
            <summary>
            Allocate space for the funny pointer lists.
            This is done only once, not once per pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.make_funny_pointers">
            <summary>
            Create the funny pointer lists discussed in the comments above.
            The actual workspace is already allocated (in main.buffer),
            and the space for the pointer lists is allocated too.
            This routine just fills in the curiously ordered lists.
            This will be repeated at the beginning of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_wraparound_pointers">
            <summary>
            Set up the "wraparound" pointers at top and bottom of the pointer lists.
            This changes the pointer list state from top-of-image to the normal state.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_main_controller.set_bottom_pointers">
            <summary>
            Change the pointer lists to duplicate the last sample row at the bottom
            of the image.  m_whichFunny indicates which m_funnyIndices holds the final iMCU row.
            Also sets rowgroups_avail to indicate number of nondummy row groups in row.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller">
            <summary>
            Decompression postprocessing (color quantization buffer control)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Boolean)">
            <summary>
            Initialize postprocessing controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_1pass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the one-pass (strip buffer) case.
            This is used for color precision reduction as well as one-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_prepass(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Int32@)">
            <summary>
            Process some data in the first pass of 2-pass quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_d_post_controller.post_process_2pass(System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Process some data in the second pass of 2-pass quantization.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_decoder">
            <summary>
            Entropy decoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_entropy_encoder">
            <summary>
            Entropy encoding
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct">
            <summary>
            Forward DCT (also controls coefficient quantization)
            
            A forward DCT routine is given a pointer to an input sample array and
            a pointer to a work area of type DCTELEM[]; the DCT is to be performed
            in-place in that buffer.  Type DCTELEM is int for 8-bit samples, INT32
            for 12-bit samples.  (NOTE: Floating-point DCT implementations use an
            array of type FAST_FLOAT, instead.)
            The input data is to be fetched from the sample array starting at a
            specified column.  (Any row offset needed will be applied to the array
            pointer before it is passed to the FDCT code.)
            Note that the number of samples fetched by the FDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            The DCT outputs are returned scaled up by a factor of 8; they therefore
            have a range of +-8K for 8-bit data, +-128K for 12-bit data.  This
            convention improves accuracy in integer implementations and saves some
            work in floating-point ones.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.forward_DCT_ptr">
            <summary>
            Perform forward DCT on one or more blocks of a component.
            
            The input samples are taken from the sample_data[] array starting at
            position start_row/start_col, and moving to the right for any additional
            blocks. The quantized coefficients are returned in coef_blocks[].
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.start_pass">
            <summary>
            Initialize for a processing pass.
            Verify that all referenced Q-tables are present, and set up
            the divisor table for each one.
            In the current implementation, DCT of all components is done during
            the first pass, even if only some components will be output in the
            first scan.  Hence all components should be examined here.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_float(System.Single[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the 
            forward DCT (Discrete Cosine Transform).
            
            This implementation should be more accurate than either of the integer
            DCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_ifast(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            This file contains a fast, not so accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            see jpeg_fdct_islow for more details.  However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            Again to save a few shifts, the intermediate results between pass 1 and
            pass 2 are not upscaled, but are represented only to integral precision.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.jpeg_fdct_islow(System.Int32[],System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Perform the forward DCT on one block of samples.
            NOTE: this code only copes with 8x8 DCTs.
            
            A slow-but-accurate integer implementation of the
            forward DCT (Discrete Cosine Transform).
            
            A 2-D DCT can be done by 1-D DCT on each row followed by 1-D DCT
            on each column.  Direct algorithms are also available, but they are
            much more complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D DCT step produces outputs which are a factor of sqrt(N)
            larger than the true DCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D DCT,
            because the y0 and y4 outputs need not be divided by sqrt(N).
            In the IJG code, this factor of 8 is removed by the quantization 
            step, NOT here.
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (For 12-bit sample data, the intermediate
            array is int anyway.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_forward_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller">
            <summary>
            Input control module
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the input controller module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.reset_input_controller">
            <summary>
            Reset state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.start_input_pass">
            <summary>
            Initialize the input modules to read a scan of compressed data.
            The first call to this is done after initializing
            the entire decompressor (during jpeg_start_decompress).
            Subsequent calls come from consume_markers, below.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.finish_input_pass">
            <summary>
            Finish up after inputting a compressed-data scan.
            This is called by the coefficient controller after it's read all
            the expected data of the scan.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.consume_markers">
            <summary>
            Read JPEG markers before, between, or after compressed-data scans.
            Change state as necessary when a new scan is reached.
            Return value is JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            The consume_input method pointer points either here or to the
            coefficient controller's consume_data routine, depending on whether
            we are reading a compressed data segment or inter-segment markers.
            
            Note: This function should NOT return a pseudo SOS marker(with zero
            component number) to the caller.A pseudo marker received by
            read_markers is processed and then skipped for other markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.initial_setup">
            <summary>
            Routines to calculate various quantities related to the size of the image.
            Called once, when first SOS marker is reached
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.latch_quant_tables">
            <summary>
            Save away a copy of the Q-table referenced by each component present
            in the current scan, unless already saved during a prior scan.
            
            In a multiple-scan JPEG file, the encoder could assign different components
            the same Q-table slot number, but change table definitions between scans
            so that each component uses a different Q-table.  (The IJG encoder is not
            currently capable of doing this, but other encoders might.)  Since we want
            to be able to dequantize all the components at the end of the file, this
            means that we have to save away the table actually used for each component.
            We do this by copying the table at the start of the first scan containing
            the component.
            The JPEG spec prohibits the encoder from changing the contents of a Q-table
            slot between scans of a component using that slot.  If the encoder does so
            anyway, this decoder will simply use the Q-table values that were current
            at the start of the first scan for the component.
            
            The decompressor output side looks only at the saved quant tables,
            not at the current Q-table slots.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_input_controller.per_scan_setup">
            <summary>
            Do computations that are needed before processing a JPEG scan
            cinfo.comps_in_scan and cinfo.cur_comp_info[] were set from SOS marker
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct">
            <summary>
            An inverse DCT routine is given a pointer to the input JBLOCK and a pointer
            to an output sample array.  The routine must dequantize the input data as
            well as perform the IDCT; for dequantization, it uses the multiplier table
            pointed to by componentInfo.dct_table.  The output data is to be placed into the
            sample array starting at a specified column. (Any row offset needed will
            be applied to the array pointer before it is passed to the IDCT code)
            Note that the number of samples emitted by the IDCT routine is
            DCT_h_scaled_size * DCT_v_scaled_size.
            
            Each IDCT routine has its own ideas about the best dct_table element type.
            
            The decompressor input side saves away the appropriate
            quantization table for each component at the start of the first scan
            involving that component.  (This is necessary in order to correctly
            decode files that reuse Q-table slots.)
            When we are ready to make an output pass, the saved Q-table is converted
            to a multiplier table that will actually be used by the IDCT routine.
            The multiplier table contents are IDCT-method-dependent.  To support
            application changes in IDCT method between scans, we can remake the
            multiplier tables if necessary.
            In buffered-image mode, the first output pass may occur before any data
            has been seen for some components, and thus before their Q-tables have
            been saved away.  To handle this case, multiplier tables are preset
            to zeroes; the result of the IDCT will be a neutral gray level.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.start_pass">
            <summary>
            Prepare for an output pass.
            Here we select the proper IDCT routine for each component and build
            a matching multiplier table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_islow(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            A slow-but-accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on an algorithm described in
            C. Loeffler, A. Ligtenberg and G. Moschytz, "Practical Fast 1-D DCT
            Algorithms with 11 Multiplications", Proc. Int'l. Conf. on Acoustics,
            Speech, and Signal Processing 1989 (ICASSP '89), pp. 988-991.
            The primary algorithm described there uses 11 multiplies and 29 adds.
            We use their alternate method with 12 multiplies and 32 adds.
            The advantage of this method is that no data path contains more than one
            multiplication; this allows a very simple and accurate implementation in
            scaled fixed-point arithmetic, with a minimal number of shifts.
            
            The poop on this scaling stuff is as follows:
            
            Each 1-D IDCT step produces outputs which are a factor of sqrt(N)
            larger than the true IDCT outputs.  The final outputs are therefore
            a factor of N larger than desired; since N=8 this can be cured by
            a simple right shift at the end of the algorithm.  The advantage of
            this arrangement is that we save two multiplications per 1-D IDCT,
            because the y0 and y4 inputs need not be divided by sqrt(N).
            
            We have to do addition and subtraction of the integer inputs, which
            is no problem, and multiplication by fractional constants, which is
            a problem to do in integer arithmetic.  We multiply all the constants
            by CONST_SCALE and convert them to integer constants (thus retaining
            SLOW_INTEGER_CONST_BITS bits of precision in the constants).  After doing a
            multiplication we have to divide the product by CONST_SCALE, with proper
            rounding, to produce the correct output.  This division can be done
            cheaply as a right shift of SLOW_INTEGER_CONST_BITS bits.  We postpone shifting
            as long as possible so that partial sums can be added together with
            full fractional precision.
            
            The outputs of the first pass are scaled up by SLOW_INTEGER_PASS1_BITS bits so that
            they are represented to better-than-integral precision.  These outputs
            require BITS_IN_JSAMPLE + SLOW_INTEGER_PASS1_BITS + 3 bits; this fits in a 16-bit word
            with the recommended scaling.  (To scale up 12-bit sample data further, an
            intermediate int array would be needed.)
            
            To avoid overflow of the 32-bit intermediate results in pass 2, we must
            have BITS_IN_JSAMPLE + SLOW_INTEGER_CONST_BITS + SLOW_INTEGER_PASS1_BITS &lt;= 26.  Error analysis
            shows that the values given below are the most effective.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_ifast(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A fast, not so accurate integer implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with fixed-point math,
            accuracy is lost due to imprecise representation of the scaled
            quantization values.  The smaller the quantization table entry, the less
            precise the scaled value, so this implementation does worse with high-
            quality-setting files than with low-quality ones.
            
            Scaling decisions are generally the same as in the LL&amp;M algorithm;
            However, we choose to descale
            (right shift) multiplication products as soon as they are formed,
            rather than carrying additional fractional bits into subsequent additions.
            This compromises accuracy slightly, but it lets us save a few shifts.
            More importantly, 16-bit arithmetic is then adequate (for 8-bit samples)
            everywhere except in the multiplications proper; this saves a good deal
            of work on 16-bit-int machines.
            
            The dequantized coefficients are not integers because the AA&amp;N scaling
            factors have been incorporated.  We represent them scaled up by FAST_INTEGER_PASS1_BITS,
            so that the first and second IDCT rounds have the same input scaling.
            For 8-bit JSAMPLEs, we choose IFAST_SCALE_BITS = FAST_INTEGER_PASS1_BITS so as to
            avoid a descaling shift; this compromises accuracy rather drastically
            for small quantization table entries, but it saves a lot of shifts.
            For 12-bit JSAMPLEs, there's no hope of using 16x16 multiplies anyway,
            so we use a much larger scaling factor to preserve accuracy.
            
            A final compromise is to represent the multiplicative constants to only
            8 fractional bits, rather than 13.  This saves some shifting work on some
            machines, and may also reduce the cost of multiplication (since there
            are fewer one-bits in the constants).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_MULTIPLY(System.Int32,System.Int32)">
            <summary>
            Multiply a DCTELEM variable by an int constant, and immediately
            descale to yield a DCTELEM result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a DCTELEM result.  For 8-bit data a 16x16->16
            multiplication will do.  For 12-bit data, the multiplier table is
            declared int, so a 32-bit multiply will be used.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FAST_INTEGER_IRIGHT_SHIFT(System.Int32,System.Int32)">
            <summary>
            Like DESCALE, but applies to a DCTELEM and produces an int.
            We assume that int right shift is unsigned if int right shift is.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_float(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients.
            NOTE: this code only copes with 8x8 DCTs.
            
            A floating-point implementation of the
            inverse DCT (Discrete Cosine Transform).  In the IJG code, this routine
            must also perform dequantization of the input coefficients.
            
            This implementation should be more accurate than either of the integer
            IDCT implementations.  However, it may not give the same results on all
            machines because of differences in roundoff behavior.  Speed will depend
            on the hardware's floating point capacity.
            
            A 2-D IDCT can be done by 1-D IDCT on each column followed by 1-D IDCT
            on each row (or vice versa, but it's more convenient to emit a row at
            a time).  Direct algorithms are also available, but they are much more
            complex and seem not to be any faster when reduced to code.
            
            This implementation is based on Arai, Agui, and Nakajima's algorithm for
            scaled DCT.  Their original paper (Trans. IEICE E-71(11):1095) is in
            Japanese, but the algorithm is described in the Pennebaker &amp; Mitchell
            JPEG textbook (see REFERENCES section in file README).  The following code
            is based directly on figure 4-8 in P&amp;M.
            While an 8-point DCT cannot be done in less than 11 multiplies, it is
            possible to arrange the computation so that many of the multiplies are
            simple scalings of the final outputs.  These multiplies can then be
            folded into the multiplications or divisions by the JPEG quantization
            table entries.  The AA&amp;N method leaves only 5 multiplies and 29 adds
            to be done in the DCT itself.
            The primary disadvantage of this method is that with a fixed-point
            implementation, accuracy is lost due to imprecise representation of the
            scaled quantization values.  However, that problem does not arise if
            we use floating point arithmetic.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.FLOAT_DEQUANTIZE(System.Int16,System.Single)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce a float result.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_4x4(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Inverse-DCT routines that produce reduced-size output:
            either 4x4, 2x2, or 1x1 pixels from an 8x8 DCT block.
            
            NOTE: this code only copes with 8x8 DCTs.
            
            The implementation is based on the Loeffler, Ligtenberg and Moschytz (LL&amp;M)
            algorithm. We simply replace each 8-to-8 1-D IDCT step
            with an 8-to-4 step that produces the four averages of two adjacent outputs
            (or an 8-to-2 step producing two averages of four outputs, for 2x2 output).
            These steps were derived by computing the corresponding values at the end
            of the normal LL&amp;M code, then simplifying as much as possible.
            
            1x1 is trivial: just take the DC coefficient divided by 8.
            
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 4x4 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_2x2(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 2x2 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.jpeg_idct_1x1(System.Int32,System.Int16[],System.Int32,System.Int32)">
            <summary>
            Perform dequantization and inverse DCT on one block of coefficients,
            producing a reduced-size 1x1 output block.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_inverse_dct.REDUCED_DEQUANTIZE(System.Int16,System.Int32)">
            <summary>
            Dequantize a coefficient by multiplying it by the multiplier-table
            entry; produce an int result.  In this module, both inputs and result
            are 16 bits or less, so either int or short multiply will work.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader">
            <summary>
            Marker reading and parsing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize the marker reader module.
            This is called only once, when the decompression object is created.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.reset_marker_reader">
            <summary>
            Reset marker processing state to begin a fresh datastream.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_markers">
            <summary>
            Read markers until SOS or EOI.
            
            Returns same codes as are defined for jpeg_consume_input:
            JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
            
            Note: This function may return a pseudo SOS marker(with zero
            component number) for treat by input controller's consume_input.
            consume_input itself should filter out (skip) the pseudo marker
            after processing for the caller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.read_restart_marker">
            <summary>
            Read a restart marker, which is expected to appear next in the datastream;
            if the marker is not there, take appropriate recovery action.
            Returns false if suspension is required.
            
            Made public for use by entropy decoder only
            
            This is called by the entropy decoder after it has read an appropriate
            number of MCUs.  cinfo.unread_marker may be nonzero if the entropy decoder
            has already read a marker from the data source.  Under normal conditions
            cinfo.unread_marker will be reset to 0 before returning; if not reset,
            it holds a marker which the decoder will be unable to read past.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.next_marker">
            <summary>
            Find the next JPEG marker, save it in cinfo.unread_marker.
            Returns false if had to suspend before reaching a marker;
            in that case cinfo.unread_marker is unchanged.
            
            Note that the result might not be a valid marker code,
            but it will never be 0 or FF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Install a special processing method for COM or APPn markers.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.save_marker(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Save an APPn or COM marker into the marker list
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.skip_variable(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Skip over an unknown or uninteresting variable-length marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_interesting_appn(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Process an APP0 or APP14 marker without saving it
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app0(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP0.
            Take appropriate action if it is a JFIF marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.examine_app14(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Examine first few bytes from an APP14.
            Take appropriate action if it is an Adobe marker.
            datalen is # of bytes at data[], remaining is length of rest of marker data.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_soi">
            <summary>
            Process an SOI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sof(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Process a SOFn marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_sos">
            <summary>
            Process a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dac">
            <summary>
            Process a DAC marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dht">
            <summary>
            Process a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dqt">
            <summary>
            Process a DQT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_dri">
            <summary>
            Process a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.get_lse">
            <summary>
            Process an LSE marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_reader.first_marker">
            <summary>
            Like next_marker, but used to obtain the initial SOI marker.
            For this marker, we do not allow preceding garbage or fill; otherwise,
            we might well scan an entire input file before realizing it ain't JPEG.
            If an application wants to process non-JFIF files, it must seek to the
            SOI before calling the JPEG library.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer">
            <summary>
            Marker writing
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_header">
            <summary>
            Write datastream header.
            This consists of an SOI and optional APPn markers.
            We recommend use of the JFIF marker, but not the Adobe marker,
            when using YCbCr or grayscale data. The JFIF marker is also used
            for other standard JPEG colorspaces. The Adobe marker is helpful
            to distinguish RGB, CMYK, and YCCK colorspaces.
            Note that an application can write additional header markers after
            jpeg_start_compress returns.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_frame_header">
            <summary>
            Write frame header.
            This consists of DQT and SOFn markers,
            a conditional LSE marker and a conditional pseudo SOS marker.
            Note that we do not emit the SOF until we have emitted the DQT(s).
            This avoids compatibility problems with incorrect implementations that
            try to error-check the quant table numbers as soon as they see the SOF.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_scan_header">
            <summary>
            Write scan header.
            This consists of DHT or DAC markers, optional DRI, and SOS.
            Compressed data will be written following the SOS.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_file_trailer">
            <summary>
            Write datastream trailer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_tables_only">
            <summary>
            Write an abbreviated table-specification datastream.
            This consists of SOI, DQT and DHT tables, and EOI.
            Any table that is defined and not marked sent_table = true will be
            emitted.  Note that all tables will be marked sent_table = true at exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_header(System.Int32,System.Int32)">
            <summary>
            Emit an arbitrary marker header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.write_marker_byte(System.Byte)">
            <summary>
            Emit one byte of marker parameters following write_marker_header
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sos">
            <summary>
            Emit a SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_lse_ict">
            <summary>
            Emit an LSE inverse color transform specification marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_sof(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a SOF marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_adobe_app14">
            <summary>
            Emit an Adobe APP14 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dri">
            <summary>
            Emit a DRI marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dht(System.Int32,System.Boolean)">
            <summary>
            Emit a DHT marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_dqt(System.Int32)">
            <summary>
            Emit a DQT marker
            </summary>
            <param name="index">The index.</param>
            <returns>the precision used (0 = 8bits, 1 = 16bits) for baseline checking</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_pseudo_sos">
            <summary>
            Emit a pseudo SOS marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_jfif_app0">
            <summary>
            Emit a JFIF-compliant APP0 marker
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_marker(BitMiracle.LibJpeg.Classic.JPEG_MARKER)">
            <summary>
            Emit a marker code
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_2bytes(System.Int32)">
            <summary>
            Emit a 2-byte integer; these are always MSB first in JPEG files
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.jpeg_marker_writer.emit_byte(System.Int32)">
            <summary>
            Emit a byte
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_scan_info">
            <summary>
            The script for encoding a multiple-scan file is an array of these:
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.jpeg_upsampler">
            <summary>
            Upsampling (note that upsampler must also call color converter)
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE">
            <summary>
            Operating modes for buffer controllers
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer">
            <summary>
            The main purpose of 1-pass quantization is to provide a fast, if not very
            high quality, colormapped output capability.  A 2-pass quantizer usually
            gives better visual quality; however, for quantized grayscale output this
            quantizer is perfectly adequate.  Dithering is highly recommended with this
            quantizer, though you can turn it off if you really want to.
            
            In 1-pass quantization the colormap must be chosen in advance of seeing the
            image.  We use a map consisting of all combinations of Ncolors[i] color
            values for the i'th component.  The Ncolors[] values are chosen so that
            their product, the total number of colors, is no more than that requested.
            (In most cases, the product will be somewhat less.)
            
            Since the colormap is orthogonal, the representative value for each color
            component can be determined without considering the other components;
            then these indexes can be combined into a colormap index by a standard
            N-dimensional-array-subscript calculation.  Most of the arithmetic involved
            can be precalculated and stored in the lookup table colorindex[].
            colorindex[i][j] maps pixel value j in component i to the nearest
            representative value (grid plane) for that component; this index is
            multiplied by the array stride for component i, so that the
            index of the colormap entry closest to a given pixel value is just
                sum( colorindex[component-number][pixel-component-value] )
            Aside from being fast, this scheme allows for variable spacing between
            representative values with no additional lookup cost.
            
            If gamma correction has been applied in color conversion, it might be wise
            to adjust the color grid spacing so that the representative colors are
            equidistant in linear space.  At this writing, gamma correction is not
            implemented, so nothing is done here.
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ...	(here)	7/16
               3/16	5/16	1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array is indexed [component#][position].
            We provide (#columns + 2) entries per component; the extra entry at each
            end saves us from special-casing the first and last pixels.
            
            
            Declarations for ordered dithering.
            
            We use a standard 16x16 ordered dither array.  The basic concept of ordered
            dithering is described in many references, for instance Dale Schumacher's
            chapter II.2 of Graphics Gems II (James Arvo, ed. Academic Press, 1991).
            In place of Schumacher's comparisons against a "threshold" value, we add a
            "dither" value to the input pixel and then round the result to the nearest
            output value.  The dither value is equivalent to (0.5 - threshold) times
            the distance between output values.  For ordered dithering, we assume that
            the output colors are equally spaced; if not, results will probably be
            worse, since the dither may be too much or too little at a given point.
            
            The normal calculation would be to form pixel value + dither, range-limit
            this to 0..MAXJSAMPLE, and then index into the colorindex table as usual.
            We can skip the separate range-limiting step by extending the colorindex
            table in both directions.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 1-pass color quantization.
            </summary>
            <param name="cinfo">The cinfo.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for one-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.finish_pass">
            <summary>
            Finish up at the end of the pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            Shouldn't get to this!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, no dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with ordered dithering.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize3_ord_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            Fast path for out_color_components==3, with ordered dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.quantize_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            General case, with Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colormap">
            <summary>
            Create the colormap.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_colorindex">
            <summary>
            Create the color index table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.create_odither_tables">
            <summary>
            Create the ordered-dither tables.
            Components having the same number of representative colors may 
            share a dither table.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.alloc_fs_workspace">
            <summary>
            Allocate workspace for Floyd-Steinberg errors.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.largest_input_value(System.Int32,System.Int32)">
            <summary>
            Return largest input value that should map to j'th output value
            Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.output_value(System.Int32,System.Int32)">
            <summary>
            Return j'th output value, where j will range from 0 to maxj
            The output values must fall in 0..MAXJSAMPLE in increasing order
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.select_ncolors(System.Int32[])">
            <summary>
            Determine allocation of desired colors to components,
            and fill in Ncolors[] array to indicate choice.
            Return value is total number of colors (product of Ncolors[] values).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_1pass_cquantizer.make_odither_array(System.Int32)">
            <summary>
            Create an ordered-dither array for a component having ncolors
            distinct output values.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer">
            <summary>
            This module implements the well-known Heckbert paradigm for color
            quantization.  Most of the ideas used here can be traced back to
            Heckbert's seminal paper
            Heckbert, Paul.  "Color Image Quantization for Frame Buffer Display",
            Proc. SIGGRAPH '82, Computer Graphics v.16 #3 (July 1982), pp 297-304.
            
            In the first pass over the image, we accumulate a histogram showing the
            usage count of each possible color.  To keep the histogram to a reasonable
            size, we reduce the precision of the input; typical practice is to retain
            5 or 6 bits per color, so that 8 or 4 different input values are counted
            in the same histogram cell.
            
            Next, the color-selection step begins with a box representing the whole
            color space, and repeatedly splits the "largest" remaining box until we
            have as many boxes as desired colors.  Then the mean color in each
            remaining box becomes one of the possible output colors.
            
            The second pass over the image maps each input pixel to the closest output
            color (optionally after applying a Floyd-Steinberg dithering correction).
            This mapping is logically trivial, but making it go fast enough requires
            considerable care.
            
            Heckbert-style quantizers vary a good deal in their policies for choosing
            the "largest" box and deciding where to cut it.  The particular policies
            used here have proved out well in experimental comparisons, but better ones
            may yet be found.
            
            In earlier versions of the IJG code, this module quantized in YCbCr color
            space, processing the raw upsampled data without a color conversion step.
            This allowed the color conversion math to be done only once per colormap
            entry, not once per pixel.  However, that optimization precluded other
            useful optimizations (such as merging color conversion with upsampling)
            and it also interfered with desired capabilities such as quantizing to an
            externally-supplied colormap.  We have therefore abandoned that approach.
            The present code works in the post-conversion color space, typically RGB.
            
            To improve the visual quality of the results, we actually work in scaled
            RGB space, giving G distances more weight than R, and R in turn more than
            B.  To do everything in integer math, we must use integer scale factors.
            The 2/3/1 scale factors used here correspond loosely to the relative
            weights of the colors in the NTSC grayscale equation.
            If you want to use this code to quantize a non-RGB color space, you'll
            probably need to change these scale factors.
            
            First we have the histogram data structure and routines for creating it.
            
            The number of bits of precision can be adjusted by changing these symbols.
            We recommend keeping 6 bits for G and 5 each for R and B.
            If you have plenty of memory and cycles, 6 bits all around gives marginally
            better results; if you are short of memory, 5 bits all around will save
            some space but degrade the results.
            To maintain a fully accurate histogram, we'd need to allocate a "long"
            (preferably unsigned long) for each cell.  In practice this is overkill;
            we can get by with 16 bits per cell.  Few of the cell counts will overflow,
            and clamping those that do overflow to the maximum value will give close-
            enough results.  This reduces the recommended histogram size from 256Kb
            to 128Kb, which is a useful savings on PC-class machines.
            (In the second pass the histogram space is re-used for pixel mapping data;
            in that capacity, each cell must be able to store zero to the number of
            desired colors.  16 bits/cell is plenty for that too.)
            Since the JPEG code is intended to run in small memory model on 80x86
            machines, we can't just allocate the histogram in one chunk.  Instead
            of a true 3-D array, we use a row of pointers to 2-D arrays.  Each
            pointer corresponds to a C0 value (typically 2^5 = 32 pointers) and
            each 2-D array has 2^6*2^5 = 2048 or 2^6*2^6 = 4096 entries.  Note that
            on 80x86 machines, the pointer row is in near memory but the actual
            arrays are in far memory (same arrangement as we use for image arrays).
            
            
            Declarations for Floyd-Steinberg dithering.
            
            Errors are accumulated into the array fserrors[], at a resolution of
            1/16th of a pixel count.  The error at a given pixel is propagated
            to its not-yet-processed neighbors using the standard F-S fractions,
                ... (here)  7/16
            3/16    5/16    1/16
            We work left-to-right on even rows, right-to-left on odd rows.
            
            We can get away with a single array (holding one row's worth of errors)
            by using it to store the current row's errors at pixel columns not yet
            processed, but the next row's errors at columns already processed.  We
            need only a few extra variables to hold the errors immediately around the
            current column.  (If we are lucky, those variables are in registers, but
            even if not, they're probably cheaper to access than array elements are.)
            
            The fserrors[] array has (#columns + 2) entries; the extra entry at
            each end saves us from special-casing the first and last pixels.
            Each entry is three values long, one value for each color component.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Module initialization routine for 2-pass color quantization.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.start_pass(System.Boolean)">
            <summary>
            Initialize for each processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.new_color_map">
            <summary>
            Switch to a new external colormap between output passes.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.prescan_quantize(System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Prescan some rows of pixels.
            In this module the prescan simply updates the histogram, which has been
            initialized to zeroes by start_pass.
            An output_buf parameter is required by the method signature, but no data
            is actually output (in fact the buffer controller is probably passing a
            null pointer).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_fs_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs Floyd-Steinberg dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.pass2_no_dither(System.Byte[][],System.Int32,System.Byte[][],System.Int32,System.Int32)">
            <summary>
            Map some rows of pixels to the output colormapped representation.
            This version performs no dithering
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.finish_pass1">
            <summary>
            Finish up at the end of each pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.compute_color(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Compute representative color for a box, put it in colormap[icolor]
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.select_colors(System.Int32)">
            <summary>
            Master routine for color selection
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.median_cut(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32,System.Int32)">
            <summary>
            Repeatedly select and split the largest box until we have enough boxes
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_color_pop(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest color population
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_biggest_volume(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Find the splittable box with the largest (scaled) volume
            Returns null if no splittable boxes remain
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.update_box(BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.box[],System.Int32)">
            <summary>
            Shrink the min/max bounds of a box to enclose only nonzero elements,
            and recompute its volume and population
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.init_error_limit">
            <summary>
            Initialize the error-limiting transfer function (lookup table).
            The raw F-S error computation can potentially compute error values of up to
            +- MAXJSAMPLE.  But we want the maximum correction applied to a pixel to be
            much less, otherwise obviously wrong pixels will be created.  (Typical
            effects include weird fringes at color-area boundaries, isolated bright
            pixels in a dark area, etc.)  The standard advice for avoiding this problem
            is to ensure that the "corners" of the color cube are allocated as output
            colors; then repeated errors in the same direction cannot cause cascading
            error buildup.  However, that only prevents the error from getting
            completely out of hand; Aaron Giles reports that error limiting improves
            the results even with corner colors allocated.
            A simple clamping of the error values to about +- MAXJSAMPLE/8 works pretty
            well, but the smoother transfer function used below is even better.  Thanks
            to Aaron Giles for this idea.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_nearby_colors(System.Int32,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Locate the colormap entries close enough to an update box to be candidates
            for the nearest entry to some cell(s) in the update box.  The update box
            is specified by the center coordinates of its first cell.  The number of
            candidate colormap entries is returned, and their colormap indexes are
            placed in colorlist[].
            This routine uses Heckbert's "locally sorted search" criterion to select
            the colors that need further consideration.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.find_best_colors(System.Int32,System.Int32,System.Int32,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Find the closest colormap entry for each cell in the update box,
            given the list of candidate colors prepared by find_nearby_colors.
            Return the indexes of the closest entries in the bestcolor[] array.
            This routine uses Thomas' incremental distance calculation method to
            find the distance from a colormap entry to successive cells in the box.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_2pass_cquantizer.fill_inverse_cmap(System.Int32,System.Int32,System.Int32)">
            <summary>
            Fill the inverse-colormap entries in the update box that contains
            histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but
            we can fill as many others as we wish.)
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressDataImpl(System.Byte[][][])">
            <summary>
            Process some data in the single-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf contains a plane for each component in image,
            which we index according to the component's SOF position.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressFirstPass(System.Byte[][][])">
            <summary>
            Process some data in the first pass of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the image.
            This amount of data is read from the source buffer, DCT'd and quantized,
            and saved into the virtual arrays.  We also generate suitable dummy blocks
            as needed at the right and lower edges.  (The dummy blocks are constructed
            in the virtual arrays, which have been padded appropriately.)  This makes
            it possible for subsequent passes not to worry about real vs. dummy blocks.
            
            We must also emit the data to the entropy encoder.  This is conveniently
            done by calling compress_output() after we've loaded the current strip
            of the virtual arrays.
            
            NB: input_buf contains a plane for each component in image.  All
            components are DCT'd and loaded into the virtual arrays in this pass.
            However, it may be that only a subset of the components are emitted to
            the entropy encoder during this first pass; be careful about looking
            at the scan-dependent variables (MCU dimensions, etc).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_c_coef_controller.compressOutput">
            <summary>
            Process some data in subsequent passes of a multi-pass case.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr">
            <summary>
            Expanded data destination object for output to Stream
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.init_destination">
            <summary>
            Initialize destination --- called by jpeg_start_compress
            before any data is actually written.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.empty_output_buffer">
            <summary>
            Empty the output buffer --- called whenever buffer fills up.
            
            In typical applications, this should write the entire output buffer
            (ignoring the current state of next_output_byte and free_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been dumped.
            
            In applications that need to be able to suspend compression due to output
            overrun, a false return indicates that the buffer cannot be emptied now.
            In this situation, the compressor will return to its caller (possibly with
            an indication that it has not accepted all the supplied scanlines).  The
            application should resume compression after it has made more room in the
            output buffer.  Note that there are substantial restrictions on the use of
            suspension --- see the documentation.
            
            When suspending, the compressor will back up to a convenient restart point
            (typically the start of the current MCU). next_output_byte and free_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point will be regenerated after resumption, so do not
            write it out when emptying the buffer externally.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_destination_mgr.term_destination">
            <summary>
            Terminate destination --- called by jpeg_finish_compress
            after all data has been written.  Usually needs to flush buffer.
            
            NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_1v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            1:1 vertical sampling case: much easier, never need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.merged_2v_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            The control routine just handles the row buffering considerations.
            2:1 vertical sampling case: may need a spare row.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v1_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][],System.Int32)">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 1:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.h2v2_merged_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32,System.Byte[][])">
            <summary>
            Upsample and color convert for the case of 2:1 horizontal and 2:1 vertical.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_ycc_rgb_table">
            <summary>
            Initialize tables for YCbCr->RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_merged_upsampler.build_bg_ycc_rgb_table">
            <summary>
            Initialize tables for BG_YCC->RGB colorspace conversion.
            This is taken directly from jpeg_color_deconverter; see that file for more info.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr">
            <summary>
            Expanded data source object for stdio input
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.#ctor(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct)">
            <summary>
            Initialize source - called by jpeg_read_header
            before any data is actually read.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_source_mgr.fill_input_buffer">
            <summary>
            Fill the input buffer - called whenever buffer is emptied.
            
            In typical applications, this should read fresh data into the buffer
            (ignoring the current state of next_input_byte and bytes_in_buffer),
            reset the pointer and count to the start of the buffer, and return true
            indicating that the buffer has been reloaded.  It is not necessary to
            fill the buffer entirely, only to obtain at least one more byte.
            
            There is no such thing as an EOF return.  If the end of the file has been
            reached, the routine has a choice of ERREXIT() or inserting fake data into
            the buffer.  In most cases, generating a warning message and inserting a
            fake EOI marker is the best course of action --- this will allow the
            decompressor to output however much of the image is there.  However,
            the resulting error message is misleading if the real problem is an empty
            input file, so we handle that case specially.
            
            In applications that need to be able to suspend compression due to input
            not being available yet, a false return indicates that no more data can be
            obtained right now, but more may be forthcoming later.  In this situation,
            the decompressor will return to its caller (with an indication of the
            number of scanlines it has read, if any).  The application should resume
            decompression after it has loaded more data into the input buffer.  Note
            that there are substantial restrictions on the use of suspension --- see
            the documentation.
            
            When suspending, the decompressor will back up to a convenient restart point
            (typically the start of the current MCU). next_input_byte and bytes_in_buffer
            indicate where the restart point will be if the current call returns false.
            Data beyond this point must be rescanned after resumption, so move it to
            the front of the buffer rather than discarding it.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller">
            <summary>
            This is a special implementation of the coefficient
            buffer controller.  This is similar to jccoefct.c, but it handles only
            output from presupplied virtual arrays.  Furthermore, we generate any
            dummy padding blocks on-the-fly rather than expecting them to be present
            in the arrays.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.#ctor(BitMiracle.LibJpeg.Classic.jpeg_compress_struct,BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Initialize coefficient buffer controller.
            
            Each passed coefficient array must be the right size for that
            coefficient: width_in_blocks wide and height_in_blocks high,
            with unit height at least v_samp_factor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_pass(BitMiracle.LibJpeg.Classic.Internal.J_BUF_MODE)">
            <summary>
            Initialize for a processing pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.compress_data(System.Byte[][][])">
            <summary>
            Process some data.
            We process the equivalent of one fully interleaved MCU row ("iMCU" row)
            per call, ie, v_samp_factor block rows for each component in the scan.
            The data is obtained from the virtual arrays and fed to the entropy coder.
            Returns true if the iMCU row is completed, false if suspended.
            
            NB: input_buf is ignored; it is likely to be a null pointer.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_trans_c_coef_controller.start_iMCU_row">
            <summary>
            Reset within-iMCU-row counters for a new row
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.start_pass">
            <summary>
            Initialize for an upsampling pass.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer[],System.Int32@,System.Int32,System.Byte[][],System.Int32@,System.Int32)">
            <summary>
            Control routine to do upsampling (and color conversion).
            
            In this version we upsample each component independently.
            We upsample one row group into the conversion buffer, then apply
            color conversion a row at a time.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.noop_upsample">
            <summary>
            This is a no-op version used for "uninteresting" components.
            These components will not be referenced by color conversion.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.fullsize_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            For full-size components, we just make color_buf[ci] point at the
            input buffer, and thus avoid copying any data.  Note that this is
            safe only because sep_upsample doesn't declare the input row group
            "consumed" until we are done color converting and emitting it.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v1_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 1:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.h2v2_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            Fast processing for the common case of 2:1 horizontal and 2:1 vertical.
            It's still a box filter.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.Internal.my_upsampler.int_upsample(BitMiracle.LibJpeg.Classic.Internal.ComponentBuffer)">
            <summary>
            This version handles any integral sampling ratios.
            This is not used for typical JPEG files, so it need not be fast.
            Nor, for that matter, is it particularly accurate: the algorithm is
            simple replication of the input pixel onto the corresponding output
            pixels.  The hi-falutin sampling literature refers to this as a
            "box filter".  A box filter tends to introduce visible artifacts,
            so if you are actually going to use 3:1 or 4:1 sampling ratios
            you would be well advised to improve this code.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JBLOCK">
            <summary>
            One block of coefficients.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JBLOCK.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The index of required element.</param>
            <value>The required element.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JHUFF_TBL">
            <summary>
            Huffman coding table.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JHUFF_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output 
            of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression. It's initialized
            <c>false</c> when the table is created, and set <c>true</c> when it's been
            output to the file. You could suppress output of a table by setting this to
            <c>true</c>. (See jpeg_suppress_tables for an example.)</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JpegConstants">
            <summary>
            Defines some JPEG constants.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE">
            <summary>
            The basic DCT block is 8x8 coefficients
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.DCTSIZE2">
            <summary>
            DCTSIZE squared; the number of elements in a block. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_QUANT_TBLS">
            <summary>
            Quantization tables are numbered 0..3 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_HUFF_TBLS">
            <summary>
            Huffman tables are numbered 0..3
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.NUM_ARITH_TBLS">
            <summary>
            Arith-coding tables are numbered 0..15
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPS_IN_SCAN">
            <summary>
            JPEG limit on the number of components in one scan.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.C_MAX_BLOCKS_IN_MCU">
            <summary>
            Compressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.D_MAX_BLOCKS_IN_MCU">
            <summary>
            Decompressor's limit on blocks per MCU.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_SAMP_FACTOR">
            <summary>
            JPEG limit on sampling factors.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAX_COMPONENTS">
            <summary>
            Maximum number of color channels allowed in JPEG image.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.BITS_IN_JSAMPLE">
            <summary>
            The size of sample.
            </summary>
            <remarks>Are either:
            8 - for 8-bit sample values (the usual setting)<br/>
            9 - for 9-bit sample values
            10 - for 10-bit sample values
            11 - for 11-bit sample values
            12 - for 12-bit sample values (not supported by this version)<br/>
            Only 8, 9, 10, 11, and 12 bits sample data precision are supported for
            full-feature DCT processing.Further depths up to 16-bit may be added
            later for the lossless modes of operation.
            Run-time selection and conversion of data precision will be added later
            and are currently not supported, sorry.
            Exception:  The transcoding part(jpegtran) supports all settings in a
            single instance, since it operates on the level of DCT coefficients and
            not sample values.The DCT coefficients are of the same type(16 bits)
            in all cases(see below).
            </remarks>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_DEFAULT">
            <summary>
            DCT method used by default.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JDCT_FASTEST">
            <summary>
            Fastest DCT method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.JPEG_MAX_DIMENSION">
            <summary>
            A tad under 64K to prevent overflows. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.MAXJSAMPLE">
            <summary>
            The maximum sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.CENTERJSAMPLE">
            <summary>
            The medium sample value.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_RED">
            <summary>
            Offset of Red in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_GREEN">
            <summary>
            Offset of Green in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_BLUE">
            <summary>
            Offset of Blue in an RGB scanline element. 
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.RGB_PIXELSIZE">
            <summary>
            Bytes per RGB scanline element.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JpegConstants.HUFF_LOOKAHEAD">
            <summary>
            The number of bits of lookahead.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct">
            <summary>Base class for both JPEG compressor and decompresor.</summary>
            <remarks>
            Routines that are to be used by both halves of the library are declared
            to receive an instance of this class. There are no actual instances of 
            <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_common_struct"/>, only of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> 
            and <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor">
            <summary>
            Base constructor.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Base constructor.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.IsDecompressor">
            <summary>
            Gets a value indicating whether this instance is Jpeg decompressor.
            </summary>
            <value>
            	<c>true</c> if this is Jpeg decompressor; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Progress">
            <summary>
            Progress monitor.
            </summary>
            <value>The progress manager.</value>
            <remarks>Default value: <c>null</c>.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Err">
            <summary>
            Error handler module.
            </summary>
            <value>The error manager.</value>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Version">
            <summary>
            Gets the version of LibJpeg.
            </summary>
            <value>The version of LibJpeg.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_common_struct.Copyright">
            <summary>
            Gets the LibJpeg's copyright.
            </summary>
            <value>The copyright.</value>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of samples.
            </summary>
            <param name="samplesPerRow">The number of samples in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)">
            <summary>
            Creates the array of blocks.
            </summary>
            <param name="blocksPerRow">The number of blocks in row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of blocks.</returns>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JBLOCK"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.AllocJpegSamples(System.Int32,System.Int32)">
            <summary>
            Creates 2-D sample array.
            </summary>
            <param name="samplesPerRow">The number of samples per row.</param>
            <param name="numberOfRows">The number of rows.</param>
            <returns>The array of samples.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">
            <summary>
            Abort processing of a JPEG compression or decompression operation,
            but don't destroy the object itself.
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_destroy">
            <summary>
            Destruction of a JPEG object. 
            
            Closing a data source or destination, if necessary, is the 
            application's responsibility.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(System.Int32,System.Object[])">
            <summary>
            Used for fatal errors (print message and exit).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.WARNMS(System.Int32,System.Object[])">
            <summary>
            Used for non-fatal errors (we can keep going, but the data is probably corrupt).
            </summary>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.TRACEMS(System.Int32,System.Int32,System.Object[])">
            <summary>
            Shows informational and debugging messages.
            </summary>
            <param name="lvl">See <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/> for description.</param>
            <param name="code">The message code.</param>
            <param name="args">The parameters of message.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_component_info">
            <summary>
            Basic info about one component (color channel).
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_id">
            <summary>
            Identifier for this component (0..255)
            </summary>
            <value>The component ID.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Component_index">
            <summary>
            Its index in SOF or <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info"/>.
            </summary>
            <value>The component index.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.H_samp_factor">
            <summary>
            Horizontal sampling factor (1..4)
            </summary>
            <value>The horizontal sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.V_samp_factor">
            <summary>
            Vertical sampling factor (1..4)
            </summary>
            <value>The vertical sampling factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Quant_tbl_no">
            <summary>
            Quantization table selector (0..3)
            </summary>
            <value>The quantization table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Dc_tbl_no">
            <summary>
            DC entropy table selector (0..3)
            </summary>
            <value>The DC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Ac_tbl_no">
            <summary>
            AC entropy table selector (0..3)
            </summary>
            <value>The AC entropy table selector.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Width_in_blocks">
            <summary>
            Gets or sets the width in blocks.
            </summary>
            <value>The width in blocks.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_component_info.Downsampled_width">
            <summary>
            Gets the downsampled width.
            </summary>
            <value>The downsampled width.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct">
            <summary>
            JPEG compression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_num">
            <summary>
            The scale numerator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.scale_denom">
            <summary>
            The scale denomenator
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.q_scale_factor">
            <summary>
            corresponding scale factors (percentage, initialized 100).
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.do_fancy_downsampling">
            <summary>
            TRUE=apply fancy downsampling
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.color_transform">
            <summary>
            Color transform identifier, writes LSE marker if nonzero
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.block_size">
            <summary>
            the basic DCT block size: 1..16
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> class.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/> class.
            </summary>
            <param name="errorManager">The error manager.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.IsDecompressor">
            <summary>
            Retrieves <c>false</c> because this is not decompressor.
            </summary>
            <value><c>false</c></value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dest">
            <summary>
            Gets or sets the destination for compressed data
            </summary>
            <value>The destination for compressed data.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_width">
            <summary>
            Gets or sets the width of image, in pixels.
            </summary>
            <value>The width of image.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Image_height">
            <summary>
            Gets or sets the height of image, in pixels.
            </summary>
            <value>The height of image.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Input_components">
            <summary>
            Gets or sets the number of color channels (components per pixel)
            </summary>
            <value>The number of color channels.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space">
            <summary>
            Gets or sets the color space of source image.
            </summary>
            <value>The color space.</value>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
            <seealso href="../articles/KB/special-color-spaces.html">Special color spaces</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Data_precision">
            <summary>
            Gets or sets the number of bits of precision in image data.
            </summary>
            <remarks>Default value: 8<br/>
            The number of bits.
            </remarks>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Num_components">
            <summary>
            Gets or sets the number of color components for JPEG color space.
            </summary>
            <value>The number of color components for JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the JPEG color space.
            </summary>
            <remarks>We recommend to use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> if you want to change this.</remarks>
            <value>The JPEG color space.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Raw_data_in">
            <summary>
            Gets or sets a value indicating whether you will be supplying raw data.
            </summary>
            <remarks>Default value: <c>false</c></remarks>
            <value><c>true</c> if you will be supplying raw data; otherwise, <c>false</c>.</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Optimize_coding">
            <summary>
            Gets or sets a value indicating a way of using Huffman coding tables.
            </summary>
            <remarks>When this is <c>true</c>, you need not supply Huffman tables at all, and any you do supply will be overwritten.</remarks>
            <value><c>true</c> causes the compressor to compute optimal Huffman coding tables 
            for the image. This requires an extra pass over the data and therefore costs a good 
            deal of space and time. The default is <c>false</c>, which tells the compressor to use the 
            supplied or default Huffman tables. In most cases optimal tables save only a few 
            percent of file size compared to the default tables.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.CCIR601_sampling">
            <summary>
            Gets or sets a value indicating whether first samples are cosited.
            </summary>
            <value><c>true</c> if first samples are cosited; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Smoothing_factor">
            <summary>
            Gets or sets the coefficient of image smoothing.
            </summary>
            <remarks>Default value: 0<br/>
            If non-zero, the input image is smoothed; the value should be 1 for minimal smoothing 
            to 100 for maximum smoothing.</remarks>
            <value>The coefficient of image smoothing.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The DCT algorithm.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval">
            <summary>
            Gets or sets the exact interval in MCU blocks.
            </summary>
            <remarks>Default value: 0<br/>
            One restart marker per MCU row is often a good choice. The overhead of restart markers 
            is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. 
            If you use restarts, you may want to use larger intervals in those cases.</remarks>
            <value>The restart interval.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_in_rows">
            <summary>
            Gets or sets the interval in MCU rows.
            </summary>
            <remarks>Default value: 0<br/>
            If Restart_in_rows is not 0, then <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval"/> is set 
            after the image width in MCUs is computed.<br/>
            One restart marker per MCU row is often a good choice. 
            The overhead of restart markers is higher in grayscale JPEG files than in color files, and MUCH higher in progressive JPEGs. If you use restarts, you may want to use larger intervals in those cases.
            </remarks>
            <value>The restart interval in MCU rows.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Restart_interval"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header">
            <summary>
            Gets or sets a value indicating whether the JFIF APP0 marker is emitted.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> and 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> set this <c>true</c> 
            if a JFIF-legal JPEG color space (i.e., YCbCr or grayscale) is selected, otherwise <c>false</c>.</remarks>
            <value><c>true</c> if JFIF APP0 marker is emitted; otherwise, <c>false</c>.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_minor_version">
            <summary>
            Gets or sets the version number to be written into the JFIF marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> initializes the version to 
            1.01 (major=minor=1). You should set it to 1.02 (major=1, minor=2) if you plan to write any 
            JFIF 1.02 extension markers.</remarks>
            <value>The version number to be written into the JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.JFIF_major_version"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit">
            <summary>
            Gets or sets the resolution information to be written into the JFIF marker; not used otherwise.
            </summary>
            <remarks>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown"/><br/>
            The pixel aspect ratio is defined by 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/> 
            even when Density_unit is <see cref="F:BitMiracle.LibJpeg.Classic.DensityUnit.Unknown">Unknown</see>.</remarks>
            <value>The density unit.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density">
            <summary>
            Gets or sets the horizontal component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The horizontal density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Y_density">
            <summary>
            Gets or sets the vertical component of pixel ratio.
            </summary>
            <remarks>Default value: 1</remarks>
            <value>The vertical density.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Density_unit"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.X_density"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker">
            <summary>
            Gets or sets a value indicating whether to emit Adobe APP14 marker.
            </summary>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/> and <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/> 
            set this <c>true</c> if JPEG color space RGB, CMYK, or YCCK is selected, otherwise <c>false</c>. 
            It is generally a bad idea to set both <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_JFIF_header"/> and 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Write_Adobe_marker"/>. 
            In fact, you probably shouldn't change the default settings at all - the default behavior ensures that the JPEG file's 
            color space can be recognized by the decoder.</remarks>
            <value>If <c>true</c> an Adobe APP14 marker is emitted; <c>false</c>, otherwise.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Component_info">
            <summary>
            Gets the components that appears in SOF.
            </summary>
            <value>The component info array.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Quant_tbl_ptrs">
            <summary>
            Gets the coefficient quantization tables.
            </summary>
            <value>The coefficient quantization tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dc_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Ac_huff_tbl_ptrs">
            <summary>
            Gets the Huffman coding tables.
            </summary>
            <value>The Huffman coding tables or null if not defined.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Next_scanline">
            <summary>
            Gets the index of next scanline to be written to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/>.
            </summary>
            <remarks>Application may use this to control its processing loop, 
            e.g., "while (Next_scanline &lt; Image_height)"</remarks>
            <value>Range: from 0 to (Image_height - 1)</value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_abort_compress">
            <summary>
            Abort processing of a JPEG compression operation.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">
            <summary>
            Forcibly suppress or un-suppress all quantization and Huffman tables.
            </summary>
            <remarks>Marks all currently defined tables as already written (if suppress)
            or not written (if !suppress). This will control whether they get 
            emitted by a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)"/> call.<br/>
            
            This routine is exported for use by applications that want to produce
            abbreviated JPEG datastreams.</remarks>
            <param name="suppress">if set to <c>true</c> then suppress tables; 
            otherwise unsuppress.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">
            <summary>
            Finishes JPEG compression.
            </summary>
            <remarks>If a multipass operating mode was selected, this may do a great 
            deal of work including most of the actual output.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])">
            <summary>
            Write a special marker.
            </summary>
            <remarks>This is only recommended for writing COM or APPn markers. 
            Must be called after <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)"/> and before first call to 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/> or <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)"/>.
            </remarks>
            <param name="marker">Specify the marker type parameter as <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>.COM for COM or 
            <see cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>.APP0 + n for APPn. (Actually, jpeg_write_marker will let you write any marker type, 
            but we don't recommend writing any other kinds of marker)</param>
            <param name="data">The data associated with the marker.</param>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)">
            <summary>
            Writes special marker's header.
            </summary>
            <param name="marker">Special marker.</param>
            <param name="datalen">Length of data associated with the marker.</param>
            <remarks>After calling this method you need to call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)"/>
            exactly the number of times given in the length parameter.<br/>
            This method lets you empty the output buffer partway through a marker, which might be important when 
            using a suspending data destination module. In any case, if you are using a suspending destination, 
            you should flush its buffer after inserting any special markers.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)"/>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_marker(System.Int32,System.Byte[])"/>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_byte(System.Byte)">
            <summary>
            Writes a byte of special marker's data.
            </summary>
            <param name="val">The byte of data.</param>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_m_header(System.Int32,System.Int32)"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">
            <summary>
            Alternate compression function: just write an abbreviated table file.
            </summary>
            <remarks>Before calling this, all parameters and a data destination must be set up.<br/>
            
            To produce a pair of files containing abbreviated tables and abbreviated
            image data, one would proceed as follows:<br/>
            
            <c>Initialize JPEG object<br/>
            Set JPEG parameters<br/>
            Set destination to table file<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables">jpeg_write_tables();</see><br/>
            Set destination to image file<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress(false);</see><br/>
            Write data...<br/>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress">jpeg_finish_compress();</see><br/>
            </c><br/>
            
            jpeg_write_tables has the side effect of marking all tables written
            (same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)">jpeg_suppress_tables(true)</see>).
            Thus a subsequent <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">jpeg_start_compress</see> 
            will not re-emit the tables unless it is passed <c>write_all_tables=true</c>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_stdio_dest(System.IO.Stream)">
            <summary>
            Sets output stream.
            </summary>
            <param name="outfile">The output stream.</param>
            <remarks>The caller must have already opened the stream, and is responsible
            for closing it after finishing compression.</remarks>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults">
            <summary>
            Jpeg_set_defaultses this instance.
            </summary>
            <remarks>Uses only the input image's color space (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space"/>, 
            which must already be set in <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>). Many applications will only need 
            to use this routine and perhaps <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)"/>.
            </remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)">
            <summary>
            Set the JPEG colorspace (property <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Jpeg_color_space"/>,
            and choose colorspace-dependent parameters appropriately.
            </summary>
            <param name="colorspace">The required colorspace.</param>
            <remarks>See <see href="../articles/KB/special-color-spaces.html">Special color spaces</see>, 
            below, before using this. A large number of parameters, including all per-component parameters, 
            are set by this routine; if you want to twiddle individual parameters you should call 
            <c>jpeg_set_colorspace</c> before rather than after.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
            <seealso href="../articles/KB/special-color-spaces.html">Special color spaces</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_colorspace">
            <summary>
            Select an appropriate JPEG colorspace based on <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.In_color_space"/>,
            and calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_colorspace(BitMiracle.LibJpeg.Classic.J_COLOR_SPACE)"/>
            </summary>
            <remarks>This is actually a subroutine of <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_defaults"/>. 
            It's broken out in case you want to change just the colorspace-dependent JPEG parameters.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)">
            <summary>
            Constructs JPEG quantization tables appropriate for the indicated quality setting.
            </summary>
            <param name="quality">The quality value is expressed on the 0..100 scale recommended by IJG.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are constrained 
            to the range 1..255 for full JPEG baseline compatibility. In the current implementation, 
            this only makes a difference for quality settings below 25, and it effectively prevents 
            very small/low quality files from being generated. The IJG decoder is capable of reading 
            the non-baseline files generated at low quality settings when <c>force_baseline</c> is <c>false</c>,
            but other decoders may not be.</param>
            <remarks>Note that the exact mapping from quality values to tables may change in future IJG releases 
            as more is learned about DCT quantization.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_default_qtables(System.Boolean)">
            <summary>
            Set or change the 'quality' (quantization) setting, using default tables
            and straight percentage-scaling quality scales.
            This entry point allows different scalings for luminance and chrominance.
            </summary>
            <param name="force_baseline">if set to <c>true</c> then baseline version is forced.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_linear_quality(System.Int32,System.Boolean)">
            <summary>
            Same as <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_set_quality(System.Int32,System.Boolean)"/> except that the generated tables are the 
            sample tables given in the JPEG specification section K.1, multiplied by 
            the specified scale factor.
            </summary>
            <param name="scale_factor">The scale_factor.</param>
            <param name="force_baseline">If <c>true</c>, then the quantization table entries are 
            constrained to the range 1..255 for full JPEG baseline compatibility. In the current 
            implementation, this only makes a difference for quality settings below 25, and it 
            effectively prevents very small/low quality files from being generated. The IJG decoder 
            is capable of reading the non-baseline files generated at low quality settings when 
            <c>force_baseline</c> is <c>false</c>, but other decoders may not be.</param>
            <remarks>Note that larger scale factors give lower quality. This entry point is 
            useful for conforming to the Adobe PostScript DCT conventions, but we do not 
            recommend linear scaling as a user-visible quality scale otherwise.
            </remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_add_quant_table(System.Int32,System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Allows an arbitrary quantization table to be created.
            </summary>
            <param name="which_tbl">Indicates which table slot to fill.</param>
            <param name="basic_table">An array of 64 unsigned integers given in normal array order.
            These values are multiplied by <c>scale_factor/100</c> and then clamped to the range 1..65535 
            (or to 1..255 if <c>force_baseline</c> is <c>true</c>).<br/>
            The basic table should be given in JPEG zigzag order.
            </param>
            <param name="scale_factor">Multiplier for values in <c>basic_table</c>.</param>
            <param name="force_baseline">Defines range of values in <c>basic_table</c>. 
            If <c>true</c> - 1..255, otherwise - 1..65535.</param>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_quality_scaling(System.Int32)">
            <summary>
            Converts a value on the IJG-recommended quality scale to a linear scaling percentage.
            </summary>
            <param name="quality">The IJG-recommended quality scale. Should be 0 (terrible) to 100 (very good).</param>
            <returns>The linear scaling percentage.</returns>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_simple_progression">
            <summary>
            Generates a default scan script for writing a progressive-JPEG file.
            </summary>
            <remarks>This is the recommended method of creating a progressive file, unless you want 
            to make a custom scan sequence. You must ensure that the JPEG color space is 
            set correctly before calling this routine.</remarks>
            <seealso href="../articles/KB/compression-parameter-selection.html">Compression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_start_compress(System.Boolean)">
            <summary>
            Starts JPEG compression.
            </summary>
            <param name="write_all_tables">Write or not write all quantization and Huffman tables.</param>
            <remarks>Before calling this, all parameters and a data destination must be set up.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_tables"/>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Write some scanlines of data to the JPEG compressor.
            </summary>
            <param name="scanlines">The array of scanlines.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The return value will be the number of lines actually written.<br/>
            This should be less than the supplied <c>num_lines</c> only in case that 
            the data destination module has requested suspension of the compressor, 
            or if more than image_height scanlines are passed in.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_write_scanlines()</c> since this likely 
            signals an application programmer error. However, excess scanlines passed in the last 
            valid call are "silently" ignored, so that the application need not adjust <c>num_lines</c>
            for end-of-image when using a multiple-scanline buffer.</remarks>
            <seealso href="../articles/KB/compression-details.html">Compression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to write raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="num_lines">The number of scanlines for writing.</param>
            <returns>The number of lines actually written.</returns>
            <remarks>Processes exactly one iMCU row per call, unless suspended.
            Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_scanlines(System.Byte[][],System.Int32)"/> when writing raw downsampled data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_write_coefficients(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Compression initialization for writing raw-coefficient data. Useful for lossless transcoding.
            </summary>
            <param name="coef_arrays">The virtual arrays need not be filled or even realized at the time 
            <c>jpeg_write_coefficients</c> is called; indeed, the virtual arrays typically will be realized 
            during this routine and filled afterwards.
            </param>
            <remarks>Before calling this, all parameters and a data destination must be set up.
            Call <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_finish_compress"/> to actually write the data.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initialize">
            <summary>
            Initialization of a JPEG compression object
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_compress_master">
            <summary>
            Master selection of compression modules.
            This is done once at the start of processing an image.  We determine
            which modules will be used and give them appropriate initialization calls.
            This routine is in charge of selecting the modules to be executed and
            making an initialization call to each one.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_master_control(System.Boolean)">
            <summary>
            Initialize master compression control.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jinit_c_main_controller(System.Boolean)">
            <summary>
            Initialize main buffer controller.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.transencode_master_selection(BitMiracle.LibJpeg.Classic.jvirt_array{BitMiracle.LibJpeg.Classic.JBLOCK}[])">
            <summary>
            Master selection of compression modules for transcoding.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.initial_setup(System.Boolean)">
            <summary>
            Do computations that are needed before master selection phase
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.validate_script">
            <summary>
            Verify that the scan script in scan_info[] is valid; 
            also determine whether it uses progressive JPEG, and set progressive_mode.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.std_huff_tables">
            <summary>
            Set up the standard Huffman tables (cf. JPEG standard section K.3)
            
            IMPORTANT: these are only valid for 8-bit data precision!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.add_huff_table(BitMiracle.LibJpeg.Classic.JHUFF_TBL@,System.Byte[],System.Byte[])">
            <summary>
            Define a Huffman table
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_a_scan(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for specified component
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_dc_scans(System.Int32@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate interleaved DC scan if possible, else N scans
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.fill_scans(System.Int32@,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Support routine: generate one scan for each component
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct">
            <summary>
            JPEG decompression routine.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method">
            <summary>
            The delegate for application-supplied marker processing methods.
            </summary>
            <param name="cinfo">Decompressor.</param>
            <returns>Return <c>true</c> to indicate success. <c>false</c> should be returned only 
            if you are using a suspending data source and it tells you to suspend.
            </returns>
            <remarks>Although the marker code is not explicitly passed, the routine can find it 
            in the <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker"/>. At the time of call, 
            the marker proper has been read from the data source module. The processor routine 
            is responsible for reading the marker length word and the remaining parameter bytes, if any.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/> class.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.#ctor(BitMiracle.LibJpeg.Classic.jpeg_error_mgr)">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/> class.
            </summary>
            <param name="errorManager">The error manager.</param>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_compress_struct"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.IsDecompressor">
            <summary>
            Retrieves <c>true</c> because this is a decompressor.
            </summary>
            <value><c>true</c></value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Src">
            <summary>
            Gets or sets the source for decompression.
            </summary>
            <value>The source for decompression.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_width">
            <summary>
            Gets the width of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>
            </summary>
            <value>The width of image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Image_height">
            <summary>
            Gets the height of image, set by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>
            </summary>
            <value>The height of image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Num_components">
            <summary>
            Gets the number of color components in JPEG image.
            </summary>
            <value>The number of color components.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Jpeg_color_space">
            <summary>
            Gets or sets the colorspace of JPEG image.
            </summary>
            <value>The colorspace of JPEG image.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">
            <summary>
            Gets the list of loaded special markers.
            </summary>
            <remarks>All the special markers in the file appear in this list, in order of 
            their occurrence in the file (but omitting any markers of types you didn't ask for)
            </remarks>
            <value>The list of loaded special markers.</value>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space">
            <summary>
            Gets or sets the output color space.
            </summary>
            <value>The output color space.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">
            <summary>
            Gets or sets the numerator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction Scale_num/<see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">Scale_denom</see>. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_denom">
            <summary>
            Gets or sets the denominator of the fraction of image scaling.
            </summary>
            <value>Scale the image by the fraction <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num">Scale_num</see>/Scale_denom. 
            Default is 1/1, or no scaling. Currently, the only supported scaling ratios are 1/1, 1/2, 1/4, and 1/8.
            (The library design allows for arbitrary scaling ratios but this is not likely to be implemented any time soon.)
            </value>
            <remarks>Smaller scaling ratios permit significantly faster decoding since fewer pixels 
            need to be processed and a simpler <see cref="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">DCT method</see> can be used.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Scale_num"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Buffered_image">
            <summary>
            Gets or sets a value indicating whether to use buffered-image mode.
            </summary>
            <value><c>true</c> if buffered-image mode is turned on; otherwise, <c>false</c>.</value>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Raw_data_out">
            <summary>
            Enable or disable raw data output.
            </summary>
            <value><c>true</c> if raw data output is enabled; otherwise, <c>false</c>.</value>
            <remarks>Default value: <c>false</c><br/>
            Set this to true before <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/> 
            if you need to obtain raw data output.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method">
            <summary>
            Gets or sets the algorithm used for the DCT step.
            </summary>
            <value>The algorithm used for the DCT step.</value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_fancy_upsampling">
            <summary>
            Enable or disable upsampling of chroma components.
            </summary>
            <value>If <c>true</c>, do careful upsampling of chroma components. 
            If <c>false</c>, a faster but sloppier method is used. 
            The visual impact of the sloppier method is often very small.
            </value>
            <remarks>Default value: <c>true</c></remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Do_block_smoothing">
            <summary>
            Apply interblock smoothing in early stages of decoding progressive JPEG files.
            </summary>
            <value>If <c>true</c>, interblock smoothing is applied in early stages of decoding progressive JPEG files; 
            if <c>false</c>, not. Early progression stages look "fuzzy" with smoothing, "blocky" without.</value>
            <remarks>Default value: <c>true</c><br/>
            In any case, block smoothing ceases to be applied after the first few AC coefficients are 
            known to full accuracy, so it is relevant only when using 
            <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> for progressive images.
            </remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">
            <summary>
            Colors quantization.
            </summary>
            <value>If set <c>true</c>, colormapped output will be delivered.<br/>
            Default value: <c>false</c>, meaning that full-color output will be delivered.
            </value>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode">
            <summary>
            Selects color dithering method.
            </summary>
            <value>Default value: <see cref="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS"/>.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            At present, ordered dither is implemented only in the single-pass, standard-colormap case. 
            If you ask for ordered dither when <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize"/> is <c>true</c>
            or when you supply an external color map, you'll get F-S dithering.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Two_pass_quantize">
            <summary>
            Gets or sets a value indicating whether to use two-pass color quantization.
            </summary>
            <value>If <c>true</c>, an extra pass over the image is made to select a custom color map for the image.
            This usually looks a lot better than the one-size-fits-all colormap that is used otherwise.
            Ignored when the application supplies its own color map.<br/>
            
            Default value: <c>true</c>
            </value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Desired_number_of_colors">
            <summary>
            Maximum number of colors to use in generating a library-supplied color map.
            </summary>
            <value>Default value: 256.</value>
            <remarks>Ignored if <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/> is <c>false</c>.<br/>
            The actual number of colors is returned in a <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/>.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_1pass_quant">
            <summary>
            Enable future use of 1-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_external_quant">
            <summary>
            Enable future use of external colormap.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Enable_2pass_quant">
            <summary>
            Enable future use of 2-pass quantizer.
            </summary>
            <value>Default value: <c>false</c></value>
            <remarks>Significant only in buffered-image mode.</remarks>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width">
            <summary>
            Gets the actual width of output image.
            </summary>
            <value>The width of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_height">
            <summary>
            Gets the actual height of output image.
            </summary>
            <value>The height of output image.</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_width"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components">
            <summary>
            Gets the number of color components in <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <value>The number of color components.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_components">
            <summary>
            Gets the number of color components returned.
            </summary>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.</remarks>
            <value>When <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors">quantizing colors</see>, 
            <c>Output_components</c> is 1, indicating a single color map index per pixel. 
            Otherwise it equals to <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components"/>.
            </value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_space"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Rec_outbuf_height">
            <summary>
            Gets the recommended height of scanline buffer.
            </summary>
            <value>In high-quality modes, <c>Rec_outbuf_height</c> is always 1, but some faster, 
            lower-quality modes set it to larger values (typically 2 to 4).</value>
            <remarks>Computed by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.
            You can also use <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions"/> to determine this value
            in advance of calling <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>.<br/>
            
            <c>Rec_outbuf_height</c> is the recommended minimum height (in scanlines) 
            of the buffer passed to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)"/>.
            If the buffer is smaller, the library will still work, but time will be wasted due 
            to unnecessary data copying. If you are going to ask for a high-speed processing mode, 
            you may as well go to the trouble of honoring <c>Rec_outbuf_height</c> so as to avoid data copying.
            (An output buffer larger than <c>Rec_outbuf_height</c> lines is OK, but won't provide 
            any material speed improvement over that height.)
            </remarks>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors">
            <summary>
            The number of colors in the color map.
            </summary>
            <value>The number of colors in the color map.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Colormap">
            <summary>
            The color map, represented as a 2-D pixel array of <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Out_color_components"/> rows 
            and <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/> columns.
            </summary>
            <value>Colormap is set to <c>null</c> by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)"/>.
            The application can supply a color map by setting <c>Colormap</c> non-null and setting 
            <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/> to the map size.
            </value>
            <remarks>Ignored if not quantizing.<br/>
            Implementation restriction: at present, an externally supplied <c>Colormap</c>
            is only accepted for 3-component output color spaces.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Actual_number_of_colors"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Quantize_colors"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scanline">
            <summary>
            Gets the number of scanlines returned so far.
            </summary>
            <value>The output_scanline.</value>
            <remarks>Usually you can just use this variable as the loop counter, 
            so that the loop test looks like 
            <c>while (cinfo.Output_scanline &lt; cinfo.Output_height)</c></remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_scan_number">
            <summary>
            Gets the number of SOS markers seen so far.
            </summary>
            <value>The number of SOS markers seen so far.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Input_iMCU_row">
            <summary>
            Gets the number of iMCU rows completed.
            </summary>
            <value>The number of iMCU rows completed.</value>
            <remarks>Indicates the progress of the decompressor input side.</remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_scan_number">
            <summary>
            Gets the nominal scan number being displayed.
            </summary>
            <value>The nominal scan number being displayed.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Output_iMCU_row">
            <summary>
            Gets the number of iMCU rows read.
            </summary>
            <value>The number of iMCU rows read.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Coef_bits">
            <summary>
            Gets the current progression status..
            </summary>
            <value><c>Coef_bits[c][i]</c> indicates the precision with 
            which component c's DCT coefficient i (in zigzag order) is known. 
            It is <c>-1</c> when no data has yet been received, otherwise 
            it is the point transform (shift) value for the most recent scan of the coefficient 
            (thus, 0 at completion of the progression). This is null when reading a non-progressive file.
            </value>
            <seealso href="../articles/KB/progressive-jpeg.html">Progressive JPEG support</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit">
            <summary>
            Gets the resolution information from JFIF marker.
            </summary>
            <value>The information from JFIF marker.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density"/>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density">
            <summary>
            Gets the horizontal component of pixel ratio.
            </summary>
            <value>The horizontal component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Y_density">
            <summary>
            Gets the vertical component of pixel ratio.
            </summary>
            <value>The vertical component of pixel ratio.</value>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.X_density"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Density_unit"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Data_precision">
            <summary>
            Gets the data precision.
            </summary>
            <value>The data precision.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Max_v_samp_factor">
            <summary>
            Gets the largest vertical sample factor.
            </summary>
            <value>The largest vertical sample factor.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Unread_marker">
            <summary>
            Gets the last read and unprocessed JPEG marker.
            </summary>
            <value>It is either zero or the code of a JPEG marker that has been
            read from the data source, but has not yet been processed.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)"/>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Comp_info">
            <summary>
            Comp_info[i] describes component that appears i'th in SOF
            </summary>
            <value>The components in SOF.</value>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_component_info"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_stdio_src(System.IO.Stream)">
            <summary>
            Sets input stream.
            </summary>
            <param name="infile">The input stream.</param>
            <remarks>
            The caller must have already opened the stream, and is responsible
            for closing it after finishing decompression.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">
            <summary>
            Decompression startup: this will read the source datastream header markers, up to the beginning of the compressed data proper.
            </summary>
            <param name="require_image">Read a description of <b>Return Value</b>.</param>
            <returns>
            If you pass <c>require_image=true</c> (normal case), you need not check for a
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY"/> return code; an abbreviated file will cause
            an error exit. <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED"/> is only possible if you use a data source
            module that can give a suspension return.<br/><br/>
            
            This method will read as far as the first SOS marker (ie, actual start of compressed data),
            and will save all tables and parameters in the JPEG object. It will also initialize the
            decompression parameters to default values, and finally return <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK"/>.
            On return, the application may adjust the decompression parameters and then call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>. (Or, if the application only wanted to
            determine the image parameters, the data need not be decompressed. In that case, call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort"/> to release any temporary space.)<br/><br/>
            
            If an abbreviated (tables only) datastream is presented, the routine will return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY"/> upon reaching EOI. The application may then re-use
            the JPEG object to read the abbreviated image datastream(s). It is unnecessary (but OK) to call
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort">jpeg_abort</see> in this case.
            The <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED"/> return code only occurs if the data source module
            requests suspension of the decompressor. In this case the application should load more source
            data and then re-call <c>jpeg_read_header</c> to resume processing.<br/><br/>
            
            If a non-suspending data source is used and <c>require_image</c> is <c>true</c>,
            then the return code need not be inspected since only <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK"/> is possible.
            </returns>
            <remarks>Need only initialize JPEG object and supply a data source before calling.<br/>
            On return, the image dimensions and other info have been stored in the JPEG object.
            The application may wish to consult this information before selecting decompression parameters.<br/>
            This routine is now just a front end to <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input"/>, with some extra error checking.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
            <seealso href="../articles/KB/decompression-parameter-selection.html">Decompression parameter selection</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress">
            <summary>
            Decompression initialization.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks><see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br/>
            
            If a multipass operating mode was selected, this will do all but the last pass, and thus may take a great deal of time.
            </remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress"/>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">
            <summary>
            Read some scanlines of data from the JPEG decompressor.
            </summary>
            <param name="scanlines">Buffer for filling.</param>
            <param name="max_lines">Required number of lines.</param>
            <returns>The return value will be the number of lines actually read. 
            This may be less than the number requested in several cases, including 
            bottom of image, data source suspension, and operating modes that emit multiple scanlines at a time.
            </returns>
            <remarks>We warn about excess calls to <c>jpeg_read_scanlines</c> since this likely signals an 
            application programmer error. However, an oversize buffer <c>(max_lines > scanlines remaining)</c> 
            is not an error.
            </remarks>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">
            <summary>
            Finish JPEG decompression.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected 
            only if a suspending data source is used.
            </returns>
            <remarks>This will normally just verify the file trailer and release temp storage.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_decompress"/>
            <seealso href="../articles/KB/decompression-details.html">Decompression details</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_raw_data(System.Byte[][][],System.Int32)">
            <summary>
            Alternate entry point to read raw data.
            </summary>
            <param name="data">The raw data.</param>
            <param name="max_lines">The number of scanlines for reading.</param>
            <returns>The number of lines actually read.</returns>
            <remarks>Replaces <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_scanlines(System.Byte[][],System.Int32)">jpeg_read_scanlines</see> 
            when reading raw downsampled data. Processes exactly one iMCU row per call, unless suspended.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_has_multiple_scans">
            <summary>
            Is there more than one scan?
            </summary>
            <returns><c>true</c> if image has more than one scan; otherwise, <c>false</c></returns>
            <remarks>If you are concerned about maximum performance on baseline JPEG files,
            you should use <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> only
            when the incoming file actually has multiple scans. This can be tested by calling this method.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)">
            <summary>
            Initialize for an output pass in <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see>.
            </summary>
            <param name="scan_number">Indicates which scan of the input file is to be displayed; 
            the scans are numbered starting at 1 for this purpose.</param>
            <returns><c>true</c> if done; <c>false</c> if suspended</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output"/>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">
            <summary>
            Finish up after an output pass in <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see>.
            </summary>
            <returns>Returns <c>false</c> if suspended. The return value need be inspected only if a suspending data source is used.</returns>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_start_output(System.Int32)"/>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_input_complete">
            <summary>
            Indicates if we have finished reading the input file.
            </summary>
            <returns><c>true</c> if we have finished reading the input file.</returns>
            <seealso href="../articles/KB/buffered-image-mode.html">Buffered-image mode</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input">
            <summary>
            Consume data in advance of what the decompressor requires.
            </summary>
            <returns>The result of data consumption.</returns>
            <remarks>This routine can be called at any time after initializing the JPEG object.
            It reads some additional data and returns when one of the indicated significant events
            occurs. If called after the EOI marker is reached, it will immediately return
            <see cref="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI"/> without attempting to read more data.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_calc_output_dimensions">
            <summary>
            Pre-calculate output image dimensions and related values for current decompression parameters.
            </summary>
            <remarks>This is allowed for possible use by application. Hence it mustn't do anything 
            that can't be done twice. Also note that it may be called before the master module is initialized!
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_coefficients">
            <summary>
            Read or write the raw DCT coefficient arrays from a JPEG file (useful for lossless transcoding).
            </summary>
            <returns>Returns <c>null</c> if suspended. This case need be checked only 
            if a suspending data source is used.
            </returns>
            <remarks>
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_read_header(System.Boolean)">jpeg_read_header</see> must be completed before calling this.<br/>
            
            The entire image is read into a set of virtual coefficient-block arrays, one per component.
            The return value is an array of virtual-array descriptors.<br/>
            
            An alternative usage is to simply obtain access to the coefficient arrays during a 
            <see href="../articles/KB/buffered-image-mode.html">buffered-image mode</see> decompression operation. This is allowed after any 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_output">jpeg_finish_output</see> call. The arrays can be accessed 
            until <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_finish_decompress">jpeg_finish_decompress</see> is called. 
            Note that any call to the library may reposition the arrays, 
            so don't rely on <see cref="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)"/> results to stay valid across library calls.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_copy_critical_parameters(BitMiracle.LibJpeg.Classic.jpeg_compress_struct)">
            <summary>
            Initializes the compression object with default parameters, then copy from the source object 
            all parameters needed for lossless transcoding.
            </summary>
            <param name="dstinfo">Target JPEG compression object.</param>
            <remarks>Parameters that can be varied without loss (such as scan script and 
            Huffman optimization) are left in their default states.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_abort_decompress">
            <summary>
            Aborts processing of a JPEG decompression operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.jpeg_abort"/>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_set_marker_processor(System.Int32,BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_marker_parser_method)">
            <summary>
            Sets processor for special marker.
            </summary>
            <param name="marker_code">The marker code.</param>
            <param name="routine">The processor.</param>
            <remarks>Allows you to supply your own routine to process 
            COM and/or APPn markers on-the-fly as they are read.
            </remarks>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_save_markers(System.Int32,System.Int32)">
            <summary>
            Control saving of COM and APPn markers into <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see>.
            </summary>
            <param name="marker_code">The marker type to save (see JPEG_MARKER enumeration).<br/>
            To arrange to save all the special marker types, you need to call this 
            routine 17 times, for COM and APP0-APP15 markers.</param>
            <param name="length_limit">If the incoming marker is longer than <c>length_limit</c> data bytes, 
            only <c>length_limit</c> bytes will be saved; this parameter allows you to avoid chewing up memory 
            when you only need to see the first few bytes of a potentially large marker. If you want to save 
            all the data, set <c>length_limit</c> to 0xFFFF; that is enough since marker lengths are only 16 bits. 
            As a special case, setting <c>length_limit</c> to 0 prevents that marker type from being saved at all. 
            (That is the default behavior, in fact.)
            </param>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list"/>
            <seealso href="../articles/KB/special-markers.html">Special markers</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.use_merged_upsample">
            <summary>
            Determine whether merged upsample/color conversion should be used.
            CRUCIAL: this must match the actual capabilities of merged upsampler!
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.initialize">
            <summary>
            Initialization of JPEG compression objects.
            The error manager must already be set up (in case memory manager fails).
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.transdecode_master_selection">
            <summary>
            Master selection of decompression modules for transcoding (that is, reading 
            raw DCT coefficient arrays from an input JPEG file.)
            This substitutes for initialization of the full decompressor.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.output_pass_setup">
            <summary>
            Set up for an output pass, and perform any dummy pass(es) needed.
            Common subroutine for jpeg_start_decompress and jpeg_start_output.
            Entry: global_state = DSTATE_PRESCAN only if previously suspended.
            Exit: If done, returns true and sets global_state for proper output mode.
                  If suspended, returns false and sets global_state = DSTATE_PRESCAN.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.default_decompress_parms">
            <summary>
            Set default decompression parameters.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr">
            <summary>
            Data destination object for compression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.init_destination">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.empty_output_buffer">
            <summary>
            Empties output buffer.
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.term_destination">
            <summary>
            Term_destinations this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.emit_byte(System.Int32)">
            <summary>
            Emits a byte.
            </summary>
            <param name="val">The byte value.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_destination_mgr.freeInBuffer">
            <summary>
            Gets the number of free bytes in buffer.
            </summary>
            <value>The number of free bytes in buffer.</value>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr">
            <summary>
            Contains simple error-reporting and trace-message routines.
            </summary>
            <remarks>This class is used by both the compression and decompression code.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr"/> class.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Trace_level">
            <summary>
            Gets or sets the maximum message level that will be displayed.
            </summary>
            <value>Values are:
            -1: recoverable corrupt-data warning, may want to abort.<br/>
            0: important advisory messages (always display to user).<br/>
            1: first level of tracing detail.<br/>
            2, 3, ...: successively more detailed tracing messages.
            </value>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)"/>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.Num_warnings">
            <summary>
            Gets the number of corrupt-data warnings.
            </summary>
            <value>The num_warnings.</value>
            <remarks>For recoverable corrupt-data errors, we emit a warning message, but keep going 
            unless <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">emit_message</see> chooses to abort. 
            <c>emit_message</c> should count warnings in <c>Num_warnings</c>. The surrounding application 
            can check for bad data by seeing if <c>Num_warnings</c> is nonzero at the end of processing.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.error_exit">
            <summary>
            Receives control for a fatal error.
            </summary>
            <remarks>This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> 
            and then throws an exception.</remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.emit_message(System.Int32)">
            <summary>
            Conditionally emit a trace or warning message.
            </summary>
            <param name="msg_level">The message severity level.<br/>
            Values are:<br/>
            -1: recoverable corrupt-data warning, may want to abort.<br/>
            0: important advisory messages (always display to user).<br/>
            1: first level of tracing detail.<br/>
            2, 3, ...: successively more detailed tracing messages.
            </param>
            <remarks>The main reason for overriding this method would be to abort on warnings.
            This method calls <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see> for message showing.<br/>
            
            An application might override this method if it wanted to abort on 
            warnings or change the policy about which messages to display.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">
            <summary>
            Actual output of any JPEG message.
            </summary>
            <remarks>Override this to send messages somewhere other than Console. 
            Note that this method does not know how to generate a message, only where to send it.
            For extending a generation of messages see <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">format_message</see>.
            </remarks>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.format_message">
            <summary>
            Constructs a readable error message string.
            </summary>
            <remarks>This method is called by <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.output_message">output_message</see>.
            Few applications should need to override this method. One possible reason for doing so is to 
            implement dynamic switching of error message language.</remarks>
            <returns>The formatted message</returns>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.reset_error_mgr">
            <summary>
            Resets error manager to initial state.
            </summary>
            <remarks>This is called during compression startup to reset trace/error
            processing to default state. An application might possibly want to
            override this method if it has additional error processing state.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_error_mgr.GetMessageText(System.Int32)">
            <summary>
            Gets the actual message texts.
            </summary>
            <param name="code">The message code. See <see cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE"/> for details.</param>
            <returns>The message text associated with <c>code</c>.</returns>
            <remarks>It may be useful for an application to add its own message texts that are handled 
            by the same mechanism. You can override <c>GetMessageText</c> for this purpose. If you number 
            the addon messages beginning at 1000 or so, you won't have to worry about conflicts 
            with the library's built-in messages.
            </remarks>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE"/>
            <seealso href="41dc1a3b-0dea-4594-87d2-c213ab1049e1.htm" target="_self">Error handling</seealso>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JPEG_MARKER">
            <summary>
            JPEG marker codes.
            </summary>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF9">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF10">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF11">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOF15">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DAC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST4">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.RST7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DQT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DNL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DRI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.DHP">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.EXP">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP1">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP2">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP3">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP4">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP5">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP6">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP7">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP8">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP9">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP10">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP11">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP12">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.APP15">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG8">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.JPG13">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.COM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.TEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.JPEG_MARKER.ERROR">
            <summary>
            
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_marker_struct">
            <summary>
            Representation of special JPEG marker.
            </summary>
            <remarks>You can't create instance of this class manually.
            Concrete objects are instantiated by library and you can get them
            through <see cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list">Marker_list</see> property.
            </remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Marker_list"/>
            <seealso href="81c88818-a5d7-4550-9ce5-024a768f7b1e.htm" target="_self">Special markers</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Marker">
            <summary>
            Gets the special marker.
            </summary>
            <value>The marker value.</value>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.OriginalLength">
            <summary>
            Gets the full length of original data associated with the marker.
            </summary>
            <value>The length of original data associated with the marker.</value>
            <remarks>This length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_marker_struct.Data">
            <summary>
            Gets the data associated with the marker.
            </summary>
            <value>The data associated with the marker.</value>
            <remarks>The length of this array doesn't exceed <c>length_limit</c> for the particular marker type.
            Note that this length excludes the marker length word, whereas the stored representation 
            within the JPEG file includes it. (Hence the maximum data length is really only 65533.)
            </remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr">
            <summary>
            The progress monitor object.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">
            <summary>
            Occurs when progress is changed.
            </summary>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_counter">
            <summary>
            Gets or sets the number of work units completed in this pass.
            </summary>
            <value>The number of work units completed in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Pass_limit">
            <summary>
            Gets or sets the total number of work units in this pass.
            </summary>
            <value>The total number of work units in this pass.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Completed_passes">
            <summary>
            Gets or sets the number of passes completed so far.
            </summary>
            <value>The number of passes completed so far.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Total_passes">
            <summary>
            Gets or sets the total number of passes expected.
            </summary>
            <value>The total number of passes expected.</value>
            <seealso href="febdc6af-ca72-4f3b-8cfe-3473ce6a7c7f.htm" target="_self">Progress monitoring</seealso>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.Updated">
            <summary>
            Indicates that progress was changed.
            </summary>
            <remarks>Call this method if you change some progress parameters manually.
            This method ensures happening of the <see cref="E:BitMiracle.LibJpeg.Classic.jpeg_progress_mgr.OnProgress">OnProgress</see> event.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jpeg_source_mgr">
            <summary>
            Data source object for decompression.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.init_source">
            <summary>
            Initializes this instance.
            </summary>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.fill_input_buffer">
            <summary>
            Fills input buffer
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.initInternalBuffer(System.Byte[],System.Int32)">
            <summary>
            Initializes the internal buffer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="size">The size.</param>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.skip_input_data(System.Int32)">
            <summary>
            Skip data - used to skip over a potentially large amount of
            uninteresting data (such as an APPn marker).
            </summary>
            <param name="num_bytes">The number of bytes to skip.</param>
            <remarks>Writers of suspendable-input applications must note that skip_input_data
            is not granted the right to give a suspension return.  If the skip extends
            beyond the data currently in the buffer, the buffer can be marked empty so
            that the next read will cause a fill_input_buffer call that can suspend.
            Arranging for additional bytes to be discarded before reloading the input
            buffer is the application writer's problem.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.resync_to_restart(BitMiracle.LibJpeg.Classic.jpeg_decompress_struct,System.Int32)">
            <summary>
            This is the default resync_to_restart method for data source 
            managers to use if they don't have any better approach.
            </summary>
            <param name="cinfo">An instance of <see cref="T:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct"/></param>
            <param name="desired">The desired</param>
            <returns><c>false</c> if suspension is required.</returns>
            <remarks>That method assumes that no backtracking is possible. 
            Some data source managers may be able to back up, or may have 
            additional knowledge about the data which permits a more 
            intelligent recovery strategy; such managers would
            presumably supply their own resync method.<br/><br/>
            
            read_restart_marker calls resync_to_restart if it finds a marker other than
            the restart marker it was expecting.  (This code is *not* used unless
            a nonzero restart interval has been declared.)  cinfo.unread_marker is
            the marker code actually found (might be anything, except 0 or FF).
            The desired restart marker number (0..7) is passed as a parameter.<br/><br/>
            
            This routine is supposed to apply whatever error recovery strategy seems
            appropriate in order to position the input stream to the next data segment.
            Note that cinfo.unread_marker is treated as a marker appearing before
            the current data-source input point; usually it should be reset to zero
            before returning.<br/><br/>
            
            This implementation is substantially constrained by wanting to treat the
            input as a data stream; this means we can't back up.  Therefore, we have
            only the following actions to work with:<br/>
            1. Simply discard the marker and let the entropy decoder resume at next
            byte of file.<br/>
            2. Read forward until we find another marker, discarding intervening
            data.  (In theory we could look ahead within the current bufferload,
            without having to discard data if we don't find the desired marker.
            This idea is not implemented here, in part because it makes behavior
            dependent on buffer size and chance buffer-boundary positions.)<br/>
            3. Leave the marker unread (by failing to zero cinfo.unread_marker).
            This will cause the entropy decoder to process an empty data segment,
            inserting dummy zeroes, and then we will reprocess the marker.<br/>
            
            #2 is appropriate if we think the desired marker lies ahead, while #3 is
            appropriate if the found marker is a future restart marker (indicating
            that we have missed the desired restart marker, probably because it got
            corrupted).<br/>
            We apply #2 or #3 if the found marker is a restart marker no more than
            two counts behind or ahead of the expected one.  We also apply #2 if the
            found marker is not a legal JPEG marker code (it's certainly bogus data).
            If the found marker is a restart marker more than 2 counts away, we do #1
            (too much risk that the marker is erroneous; with luck we will be able to
            resync at some future point).<br/>
            For any valid non-restart JPEG marker, we apply #3.  This keeps us from
            overrunning the end of a scan.  An implementation limited to single-scan
            files might find it better to apply #2 for markers other than EOI, since
            any other marker would have to be bogus data in that case.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.term_source">
            <summary>
            Terminate source - called by jpeg_finish_decompress
            after all data has been read.  Often a no-op.
            </summary>
            <remarks>NB: <b>not</b> called by jpeg_abort or jpeg_destroy; surrounding
            application must deal with any cleanup that should happen even
            for error exit.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetTwoBytes(System.Int32@)">
            <summary>
            Reads two bytes interpreted as an unsigned 16-bit integer.
            </summary>
            <param name="V">The result.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetByte(System.Int32@)">
            <summary>
            Read a byte into variable V.
            If must suspend, take the specified action (typically "return false").
            </summary>
            <param name="V">The result.</param>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.GetBytes(System.Byte[],System.Int32)">
            <summary>
            Gets the bytes.
            </summary>
            <param name="dest">The destination.</param>
            <param name="amount">The amount.</param>
            <returns>The number of available bytes.</returns>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jpeg_source_mgr.MakeByteAvailable">
            <summary>
            Functions for fetching data from the data source module.
            </summary>
            <returns><c>true</c> if operation succeed; otherwise, <c>false</c></returns>
            <remarks>At all times, cinfo.src.next_input_byte and .bytes_in_buffer reflect
            the current restart point; we update them only when we have reached a
            suitable place to restart if a suspension occurs.</remarks>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.JQUANT_TBL">
            <summary>
            DCT coefficient quantization tables.
            </summary>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.JQUANT_TBL.Sent_table">
            <summary>
            Gets or sets a value indicating whether the table has been output to file.
            </summary>
            <value>It's initialized <c>false</c> when the table is created, and set 
            <c>true</c> when it's been output to the file. You could suppress output of a table by setting this to <c>true</c>.
            </value>
            <remarks>This property is used only during compression.</remarks>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.jpeg_suppress_tables(System.Boolean)"/>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.jvirt_array`1">
            <summary>
            JPEG virtual array.
            </summary>
            <typeparam name="T">The type of array's elements.</typeparam>
            <remarks>You can't create virtual array manually. For creation use methods
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateSamplesArray(System.Int32,System.Int32)"/> and
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.CreateBlocksArray(System.Int32,System.Int32)"/>.
            </remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.#ctor(System.Int32,System.Int32,BitMiracle.LibJpeg.Classic.jvirt_array{`0}.Allocator)">
            <summary>
            Request a virtual 2-D array
            </summary>
            <param name="width">Width of array</param>
            <param name="height">Total virtual array height</param>
            <param name="allocator">The allocator.</param>
        </member>
        <member name="P:BitMiracle.LibJpeg.Classic.jvirt_array`1.ErrorProcessor">
            <summary>
            Gets or sets the error processor.
            </summary>
            <value>The error processor.<br/>
            Default value: <c>null</c>
            </value>
            <remarks>Uses only for calling 
            <see cref="M:BitMiracle.LibJpeg.Classic.jpeg_common_struct.ERREXIT(BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE)">jpeg_common_struct.ERREXIT</see>
            on error.</remarks>
        </member>
        <member name="M:BitMiracle.LibJpeg.Classic.jvirt_array`1.Access(System.Int32,System.Int32)">
            <summary>
            Access the part of a virtual array.
            </summary>
            <param name="startRow">The first row in required block.</param>
            <param name="numberOfRows">The number of required rows.</param>
            <returns>The required part of virtual array.</returns>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE">
            <summary>
            Known color spaces.
            </summary>
            <seealso href="c90654b9-f3f4-4319-80d1-979c73d84e76.htm" target="_self">Special color spaces</seealso>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_UNKNOWN">
            <summary>
            Unspecified color space.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_GRAYSCALE">
            <summary>
            Monochrome
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_RGB">
            <summary>
            Red/Green/Blue, standard RGB (sRGB)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCbCr">
            <summary>
            Y/Cb/Cr (also known as YUV), standard YCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_CMYK">
            <summary>
            C/M/Y/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_YCCK">
            <summary>
             Y/Cb/Cr/K
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_RGB">
            <summary>
            big gamut red/green/blue, bg-sRGB
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_BG_YCC">
            <summary>
            big gamut Y/Cb/Cr, bg-sYCC
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_SPACE.JCS_NCHANNEL">
            <summary>
            N channels
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM">
            <summary>
            Supported color transforms.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_NONE">
            <summary>
            No transform
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_COLOR_TRANSFORM.JCT_SUBTRACT_GREEN">
            <summary>
            Substract green
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DCT_METHOD">
            <summary>
            Algorithm used for the DCT step.
            </summary>
            <remarks>The <c>FLOAT</c> method is very slightly more accurate than the <c>ISLOW</c> method,
            but may give different results on different machines due to varying roundoff behavior.
            The integer methods should give the same results on all machines. On machines with
            sufficiently fast hardware, the floating-point method may also be the fastest.
            The <c>IFAST</c> method is considerably less accurate than the other two; its use is not recommended
            if high quality is a concern.</remarks>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_compress_struct.Dct_method"/>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dct_method"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_ISLOW">
            <summary>
            Slow but accurate integer algorithm.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_IFAST">
            <summary>
            Faster, less accurate integer method.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DCT_METHOD.JDCT_FLOAT">
            <summary>
            Floating-point method.
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_DITHER_MODE">
            <summary>
            Dithering options for decompression.
            </summary>
            <seealso cref="P:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.Dither_mode"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_NONE">
            <summary>
            No dithering: fast, very low quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_ORDERED">
            <summary>
            Ordered dither: moderate speed and quality
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_DITHER_MODE.JDITHER_FS">
            <summary>
            Floyd-Steinberg dither: slow, high quality
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE">
            <summary>
            Message codes used in code to signal errors, warning and trace messages.
            </summary>
            <seealso cref="T:BitMiracle.LibJpeg.Classic.jpeg_error_mgr"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_NOMESSAGE">
            <summary>
            Must be first entry!
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_BUFFER_MODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_COMPONENT_ID">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_CROP_SPEC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCT_COEF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DCTSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_DROP_SAMPLING">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_HUFF_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_IN_COLORSPACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_J_COLORSPACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_LENGTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_MCU_SIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PRECISION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROGRESSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_PROG_SCRIPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SAMPLING">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_SCAN_SCRIPT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_STATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BAD_VIRTUAL_ACCESS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_BUFFER_SIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CANT_SUSPEND">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CCIR601_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_COMPONENT_COUNT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_CONVERSION_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DAC_VALUE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DHT_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_DQT_INDEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EMPTY_IMAGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_EOI_EXPECTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FILE_WRITE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_FRACT_SAMPLE_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_CLEN_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_HUFF_MISSING_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_IMAGE_TOO_BIG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EMPTY">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_INPUT_EOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISMATCHED_QUANT_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MISSING_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_MODE_CHANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NOT_COMPILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_ARITH_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_HUFF_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_IMAGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_QUANT_TABLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_NO_SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_OUT_OF_MEMORY">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_COMPONENTS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_FEW_COLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_QUANT_MANY_COLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_BEFORE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_DUPLICATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_NO_SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOF_UNSUPPORTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOI_DUPLICATE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_SOS_NO_SOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_TOO_LITTLE_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_UNKNOWN_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JERR_WIDTH_OVERFLOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_16BIT_TABLES">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_ADOBE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP0">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_APP14">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DAC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DQT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_DRI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_EOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_HUFFBITS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_BADTHUMBNAILSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_EXTENSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_JFIF_THUMBNAIL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_MISC_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_PARMLESS_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANTVALS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_3_NCOLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_NCOLORS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_QUANT_SELECTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RECOVERY_ACTION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_RST">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SMOOTH_NOTIMPL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOF_COMPONENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_COMPONENT">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_SOS_PARAMS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_JPEG">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_PALETTE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_THUMB_RGB">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JTRC_UNKNOWN_IDS">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ADOBE_XFORM">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_ARITH_BAD_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_BOGUS_PROGRESSION">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_EXTRANEOUS_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HIT_MARKER">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_HUFF_BAD_CODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JFIF_MAJOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_JPEG_EOF">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_MUST_RESYNC">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_NOT_SEQUENTIAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JWRN_TOO_MUCH_DATA">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_UNKNOWNMSGCODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.J_MESSAGE_CODE.JMSG_LASTMSGCODE">
            <summary>
            
            </summary>
        </member>
        <member name="T:BitMiracle.LibJpeg.Classic.ReadResult">
            <summary>
            Describes a result of read operation.
            </summary>
            <seealso cref="M:BitMiracle.LibJpeg.Classic.jpeg_decompress_struct.jpeg_consume_input"/>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SUSPENDED">
            <summary>
            Suspended due to lack of input data. Can occur only if a suspending data source is used.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_OK">
            <summary>
            Found valid image datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_HEADER_TABLES_ONLY">
            <summary>
            Found valid table-specs-only datastream.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_SOS">
            <summary>
            Reached a SOS marker (the start of a new scan)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_REACHED_EOI">
            <summary>
            Reached the EOI marker (end of image)
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_ROW_COMPLETED">
            <summary>
            Completed reading one MCU row of compressed data.
            </summary>
        </member>
        <member name="F:BitMiracle.LibJpeg.Classic.ReadResult.JPEG_SCAN_COMPLETED">
            <summary>
            Completed reading last MCU row of current scan.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to read from.</param>
            <param name="target">Contains the array of characteres read from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source Stream.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to read from</param>
            <param name="target">Contains the array of characteres read from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to read from the source TextReader.</param>
            <returns>The number of characters read. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the end of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ToByteArray(System.String)">
            <summary>
            Converts a string to an array of bytes
            </summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.zlib.SupportClass.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZInputStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZInputStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZOutputStream.TotalIn">
            <summary> Returns the total number of bytes input so far.</summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.zlib.ZOutputStream.TotalOut">
            <summary> Returns the total number of bytes output so far.</summary>
        </member>
    </members>
</doc>
